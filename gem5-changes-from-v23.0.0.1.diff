diff --git a/.gitignore b/.gitignore
index 229a0d5ae9..529df689b8 100644
--- a/.gitignore
+++ b/.gitignore
@@ -32,3 +32,8 @@ configs/example/memcheck.cfg
 configs/dram/lowp_sweep.cfg
 .pyenv
 .vscode
+lab4/
+AGENTS.md
+.gitignore
+hop_analysis.py
+m5out*/
diff --git a/configs/example/garnet_synth_traffic.py b/configs/example/garnet_synth_traffic.py
index 1da82e11b8..276dd20cf1 100644
--- a/configs/example/garnet_synth_traffic.py
+++ b/configs/example/garnet_synth_traffic.py
@@ -173,7 +173,7 @@ root = Root(full_system=False, system=system)
 root.system.mem_mode = "timing"

 # Not much point in this being higher than the L1 latency
-m5.ticks.setGlobalFrequency("1ps")
+m5.ticks.setGlobalFrequency("500ps")

 # instantiate configuration
 m5.instantiate()
diff --git a/configs/network/Network.py b/configs/network/Network.py
index a5334741c0..c05312d668 100644
--- a/configs/network/Network.py
+++ b/configs/network/Network.py
@@ -44,7 +44,7 @@ def define_options(parser):
     parser.add_argument(
         "--mesh-rows",
         type=int,
-        default=0,
+        default=4,
         help="the number of rows in the mesh topology",
     )
     parser.add_argument(
@@ -72,6 +72,28 @@ def define_options(parser):
         Has to be >= 1. Can be over-ridden on a per link basis
         in the topology file.""",
     )
+    parser.add_argument(
+        "--vlink-slowdown",
+        action="store",
+        type=int,
+        default=4,
+        help="Multiply Z-axis (vertical/TSV) link latency by this factor.",
+    )
+    # Additional TSV controls (used by sparse/hub 3D topologies)
+    parser.add_argument(
+        "--tsv-slowdown",
+        action="store",
+        type=int,
+        default=4,
+        help="Multiply Z-link (TSV) latency by this factor (default: 4)",
+    )
+    parser.add_argument(
+        "--tsv-speedup",
+        action="store",
+        type=int,
+        default=1,
+        help="Divide Z-link (TSV) latency by this factor (effective latency = link_latency * SLOWDOWN / SPEEDUP; default: 1)",
+    )
     parser.add_argument(
         "--link-width-bits",
         action="store",
@@ -95,7 +117,10 @@ def define_options(parser):
         help="""routing algorithm in network.
             0: weight-based table
             1: XY (for Mesh. see garnet/RoutingUnit.cc)
-            2: Custom (see garnet/RoutingUnit.cc""",
+            2: Custom (see garnet/RoutingUnit.cc)
+            3: Adaptive minimal, credit-aware (3D-ready)
+            4: CAR-3D (EWMA + lookahead-inspired scoring)
+            5: UGAL-L (local, single-segment at source)""",
     )
     parser.add_argument(
         "--network-fault-model",
@@ -119,6 +144,52 @@ def define_options(parser):
             channel for each virtual network""",
     )

+    parser.add_argument(
+        "--escape-vc",
+        default=False,
+        action="store_true",
+        help="Enable escape virtual channel",
+    )
+
+    parser.add_argument(
+        "--escape-fallback-wait",
+        type=int,
+        default=0,
+        help="Wait time for escape virtual channel fallback",
+    )
+
+    # SPIN scheme (optional)
+    parser.add_argument(
+        "--enable-spin-scheme",
+        action="store_true",
+        default=False,
+        help="Enable SPIN synchronized-progress scheme (freeze+escape fallback)",
+    )
+    parser.add_argument(
+        "--dd-thresh",
+        type=int,
+        default=300,
+        help="SPIN deadlock-detection threshold in cycles",
+    )
+    parser.add_argument(
+        "--max-turn-capacity",
+        type=int,
+        default=100,
+        help="SPIN: maximum number of turns for a probe path",
+    )
+
+    # Routing knobs (CAR3D/UGAL/UGAL+) exposed to CLI
+    parser.add_argument("--ewma-lambda", type=float, default=0.2,
+                        help="EWMA smoothing for outport credits (0..1)")
+    parser.add_argument("--car3d-alpha", type=float, default=1.0,
+                        help="CAR3D weight on instantaneous credits")
+    parser.add_argument("--car3d-beta",  type=float, default=0.5,
+                        help="CAR3D weight on EWMA credits")
+
+    parser.add_argument("--ugal-penalty", type=int, default=2,
+                        help="UGAL-L non-min detour penalty (hop-equivalent)")
+    parser.add_argument("--ugal-tol", type=float, default=1.0,
+                        help="UGAL-L tolerance multiplier (<1 encourages non-min)")

 def create_network(options, ruby):

@@ -169,6 +240,21 @@ def init_network(options, network, InterfaceClass):
         network.ni_flit_size = options.link_width_bits / 8
         network.routing_algorithm = options.routing_algorithm
         network.garnet_deadlock_threshold = options.garnet_deadlock_threshold
+        network.escape_vc_enabled = options.escape_vc
+        # network.escape_fallback_wait = options.escape_fallback_wait
+        # SPIN
+        network.enable_spin_scheme = options.enable_spin_scheme
+        network.dd_thresh = options.dd_thresh
+        network.max_turn_capacity = options.max_turn_capacity
+
+        # Routing knobs
+        network.ewma_lambda = options.ewma_lambda
+        network.car3d_alpha = options.car3d_alpha
+        network.car3d_beta  = options.car3d_beta
+
+        network.ugal_penalty = options.ugal_penalty
+        network.ugal_tol     = options.ugal_tol
+

         # Create Bridges and connect them to the corresponding links
         for intLink in network.int_links:
diff --git a/configs/topologies/Cluster3D_Hub.py b/configs/topologies/Cluster3D_Hub.py
new file mode 100644
index 0000000000..ac2ca57b14
--- /dev/null
+++ b/configs/topologies/Cluster3D_Hub.py
@@ -0,0 +1,236 @@
+# configs/topologies/Cluster3D_Hub.py
+
+from m5.params import *
+from m5.objects import *
+
+from common import FileSystemConfig
+from topologies.BaseTopology import SimpleTopology
+
+
+class Cluster3D_Hub(SimpleTopology):
+    description = "Cluster3D_Hub"
+
+    # ===================== configs =====================
+    # Hub router  latency= max(1, router_latency // HUB_SPEEDUP)
+    HUB_SPEEDUP = 2
+
+    CLUSTER_SIDE = 2
+    # ===================== configs =====================
+
+    def __init__(self, controllers):
+        self.nodes = controllers
+
+    def makeTopology(self, options, network, IntLink, ExtLink, Router):
+        nodes = self.nodes
+
+        # ------- X=Y -------
+        X = int(options.mesh_rows)
+        Y = int(options.mesh_rows)
+        assert X > 0 and Y > 0 and X == Y, "本脚本假设每层是 X==Y 的方阵"
+
+        N_HR = int(options.num_cpus)
+        assert (N_HR % (X * Y)) == 0, "num_cpus 必须能整除 X*Y 才能得到整数层数"
+        Z = N_HR // (X * Y)
+        assert Z > 0, "层数 Z 必须 > 0"
+
+        # num of clusters per layer
+        assert (
+            X % self.CLUSTER_SIDE == 0 and Y % self.CLUSTER_SIDE == 0
+        ), "X/Y 必须能被簇边长整除"
+        hubs_per_layer = (X // self.CLUSTER_SIDE) * (Y // self.CLUSTER_SIDE)
+        N_HBR = Z * hubs_per_layer  # Hub Router
+
+        # Link Latency
+        link_latency = int(options.link_latency)
+        router_latency = int(options.router_latency)
+
+        # Z = link_latency * SLOWDOWN / SPEEDUP
+        tsv_slow = max(1, int(getattr(options, "tsv_slowdown", 4)))
+        tsv_fast = max(1, int(getattr(options, "tsv_speedup", 1)))
+
+        vlink_latency = max(1, int(link_latency) * tsv_slow // tsv_fast)
+        hub_latency = max(1, router_latency // max(1, self.HUB_SPEEDUP))
+
+        # ------- id -------
+        def hr_id(x, y, z):
+            return z * (X * Y) + y * X + x
+
+        def hbr_id(cx, cy, z):
+
+            idx_in_layer = cy * (X // self.CLUSTER_SIDE) + cx
+            return N_HR + z * hubs_per_layer + idx_in_layer
+
+        # ------- Add Routers -------
+        routers = []
+        for i in range(N_HR):
+            routers.append(Router(router_id=i, latency=router_latency))
+        for j in range(N_HBR):
+            routers.append(Router(router_id=N_HR + j, latency=hub_latency))
+        network.routers = routers
+
+        # ------- ExtLink -------
+        ext_links = []
+        link_id = 0
+        cntrls_per_router, remainder = divmod(len(nodes), N_HR)
+        network_nodes = nodes[: len(nodes) - remainder]
+        remainder_nodes = nodes[len(nodes) - remainder :]
+
+        for i, n in enumerate(network_nodes):
+            level, rid = divmod(i, N_HR)
+            assert level < cntrls_per_router
+            ext_links.append(
+                ExtLink(
+                    link_id=link_id,
+                    ext_node=n,
+                    int_node=routers[rid],
+                    latency=link_latency,
+                )
+            )
+            link_id += 1
+
+        for i, n in enumerate(remainder_nodes):
+            assert n.type == "DMA_Controller" and i < remainder
+            ext_links.append(
+                ExtLink(
+                    link_id=link_id,
+                    ext_node=n,
+                    int_node=routers[0],
+                    latency=link_latency,
+                )
+            )
+            link_id += 1
+
+        network.ext_links = ext_links
+
+        # ------- IntLink -------
+        int_links = []
+
+        for z in range(Z):
+            for y in range(Y):
+                for x in range(X):
+                    u = hr_id(x, y, z)
+                    if x + 1 < X:
+                        v = hr_id(x + 1, y, z)
+                        # u -> v (East), v -> u (West)
+                        int_links.append(
+                            IntLink(
+                                link_id=link_id,
+                                src_node=routers[u],
+                                dst_node=routers[v],
+                                src_outport="East",
+                                dst_inport="West",
+                                latency=link_latency,
+                                weight=1,
+                            )
+                        )
+                        link_id += 1
+                        int_links.append(
+                            IntLink(
+                                link_id=link_id,
+                                src_node=routers[v],
+                                dst_node=routers[u],
+                                src_outport="West",
+                                dst_inport="East",
+                                latency=link_latency,
+                                weight=1,
+                            )
+                        )
+                        link_id += 1
+                    if y + 1 < Y:
+                        v = hr_id(x, y + 1, z)
+                        # u -> v (North), v -> u (South)
+                        int_links.append(
+                            IntLink(
+                                link_id=link_id,
+                                src_node=routers[u],
+                                dst_node=routers[v],
+                                src_outport="North",
+                                dst_inport="South",
+                                latency=link_latency,
+                                weight=2,
+                            )
+                        )
+                        link_id += 1
+                        int_links.append(
+                            IntLink(
+                                link_id=link_id,
+                                src_node=routers[v],
+                                dst_node=routers[u],
+                                src_outport="South",
+                                dst_inport="North",
+                                latency=link_latency,
+                                weight=2,
+                            )
+                        )
+                        link_id += 1
+
+        for z in range(Z):
+            for y in range(Y):
+                for x in range(X):
+                    cx, cy = x // self.CLUSTER_SIDE, y // self.CLUSTER_SIDE
+                    hub = hbr_id(cx, cy, z)
+                    h = hr_id(x, y, z)
+                    int_links.append(
+                        IntLink(
+                            link_id=link_id,
+                            src_node=routers[h],
+                            dst_node=routers[hub],
+                            src_outport="ToHub",
+                            dst_inport="FromCluster",
+                            latency=link_latency,
+                            weight=3,
+                        )
+                    )
+                    link_id += 1
+                    int_links.append(
+                        IntLink(
+                            link_id=link_id,
+                            src_node=routers[hub],
+                            dst_node=routers[h],
+                            src_outport="ToCluster",
+                            dst_inport="FromHub",
+                            latency=link_latency,
+                            weight=3,
+                        )
+                    )
+                    link_id += 1
+
+        for z in range(Z - 1):
+            for cy in range(Y // self.CLUSTER_SIDE):
+                for cx in range(X // self.CLUSTER_SIDE):
+                    a = hbr_id(cx, cy, z)
+                    b = hbr_id(cx, cy, z + 1)
+                    # a -> b : Up
+                    int_links.append(
+                        IntLink(
+                            link_id=link_id,
+                            src_node=routers[a],
+                            dst_node=routers[b],
+                            src_outport="Up",
+                            dst_inport="Down",
+                            latency=vlink_latency,
+                            weight=4,
+                        )
+                    )
+                    link_id += 1
+                    # b -> a : Down
+                    int_links.append(
+                        IntLink(
+                            link_id=link_id,
+                            src_node=routers[b],
+                            dst_node=routers[a],
+                            src_outport="Down",
+                            dst_inport="Up",
+                            latency=vlink_latency,
+                            weight=4,
+                        )
+                    )
+                    link_id += 1
+
+        network.int_links = int_links
+
+    def registerTopology(self, options):
+        for i in range(options.num_cpus):
+            FileSystemConfig.register_node(
+                [i], MemorySize(options.mem_size) // options.num_cpus, i
+            )
diff --git a/configs/topologies/Hier3D_Chiplet.py b/configs/topologies/Hier3D_Chiplet.py
new file mode 100644
index 0000000000..b17e0d897b
--- /dev/null
+++ b/configs/topologies/Hier3D_Chiplet.py
@@ -0,0 +1,239 @@
+from m5.params import *
+from m5.objects import *
+
+from common import FileSystemConfig
+from topologies.BaseTopology import SimpleTopology
+
+
+# =========================
+# ===== configs ======
+# =========================
+
+# size of a chiplet
+CHIP_X = 2
+CHIP_Y = 2
+CHIP_Z = 1
+
+# num of gateways per chiplet
+GW_PER_CHIPLET = 1
+
+# WEIGHT
+W_INTRA = 1
+W_BACKBONE = 2
+W_VERTICAL = 3
+
+# =========================
+# ===== configs ======
+# =========================
+
+
+class Hier3D_Chiplet(SimpleTopology):
+    description = "Hier3D_Chiplet"
+
+    def __init__(self, controllers):
+        self.nodes = controllers
+
+    # Helper: coordinate and router_id
+    @staticmethod
+    def _rid(x, y, z, X, Y):
+        return z * (X * Y) + y * X + x
+
+    def makeTopology(self, options, network, IntLink, ExtLink, Router):
+        nodes = self.nodes
+
+        num_routers = options.num_cpus
+        Y = options.mesh_rows
+        assert Y > 0
+        X = Y
+        assert (
+            num_routers % (X * Y)
+        ) == 0, "num_cpus must be a multiple of mesh_rows^2"
+        Z = num_routers // (X * Y)
+        assert Z > 0
+
+        # Latency
+        link_latency = int(options.link_latency)
+        router_latency = int(options.router_latency)
+        tsv_slowdown = max(1, int(getattr(options, "tsv_slowdown", 4)))
+        tsv_speedup = max(1, int(getattr(options, "tsv_speedup", 1)))
+        vlink_latency = max(1, int(link_latency) * tsv_slowdown // tsv_speedup)
+
+        routers = [
+            Router(router_id=i, latency=router_latency)
+            for i in range(num_routers)
+        ]
+        network.routers = routers
+
+        link_count = 0
+        cntrls_per_router, remainder = divmod(len(nodes), num_routers)
+        ext_links = []
+        for (i, n) in enumerate(nodes[: len(nodes) - remainder]):
+            cntrl_level, r_id = divmod(i, num_routers)
+            assert cntrl_level < cntrls_per_router
+            ext_links.append(
+                ExtLink(
+                    link_id=link_count,
+                    ext_node=n,
+                    int_node=routers[r_id],
+                    latency=link_latency,
+                )
+            )
+            link_count += 1
+
+        for (i, n) in enumerate(nodes[len(nodes) - remainder :]):
+            ext_links.append(
+                ExtLink(
+                    link_id=link_count,
+                    ext_node=n,
+                    int_node=routers[0],
+                    latency=link_latency,
+                )
+            )
+            link_count += 1
+
+        network.ext_links = ext_links
+
+        assert (
+            X % CHIP_X == 0 and Y % CHIP_Y == 0 and Z % CHIP_Z == 0
+        ), "Global dims (X,Y,Z) must be divisible by chiplet dims (CHIP_X,CHIP_Y,CHIP_Z)"
+
+        CX = X // CHIP_X
+        CY = Y // CHIP_Y
+        CZ = Z // CHIP_Z  # chiplet layer num
+
+        gw_x_map = {}
+        gw_y_map = {}
+
+        def choose_one_gateway(x0, y0, z0):
+
+            gx = min(x0 + CHIP_X // 2, x0 + CHIP_X - 1)
+            gy = min(y0 + CHIP_Y // 2, y0 + CHIP_Y - 1)
+            gz = min(z0 + CHIP_Z // 2, z0 + CHIP_Z - 1)
+            return (gx, gy, gz)
+
+        def choose_two_gateways(x0, y0, z0):
+
+            gx0 = x0
+            gy0 = min(y0 + CHIP_Y // 2, y0 + CHIP_Y - 1)
+            gz0 = min(z0 + CHIP_Z // 2, z0 + CHIP_Z - 1)
+
+            gx1 = min(x0 + CHIP_X // 2, x0 + CHIP_X - 1)
+            gy1 = y0
+            gz1 = gz0
+            return (gx0, gy0, gz0), (gx1, gy1, gz1)
+
+        for cz in range(CZ):
+            for cy in range(CY):
+                for cx in range(CX):
+                    x0 = cx * CHIP_X
+                    y0 = cy * CHIP_Y
+                    z0 = cz * CHIP_Z
+                    if GW_PER_CHIPLET == 1:
+                        gx, gy, gz = choose_one_gateway(x0, y0, z0)
+                        gw_x_map[(cx, cy, cz)] = (gx, gy, gz)
+                        gw_y_map[(cx, cy, cz)] = (gx, gy, gz)
+                    else:
+                        (gx0, gy0, gz0), (gx1, gy1, gz1) = choose_two_gateways(
+                            x0, y0, z0
+                        )
+                        gw_x_map[(cx, cy, cz)] = (gx0, gy0, gz0)  # X
+                        gw_y_map[(cx, cy, cz)] = (gx1, gy1, gz1)  # Y
+
+        # ------------- IntLink-------------
+        int_links = []
+
+        def add_link(src_id, dst_id, src_port, dst_port, w):
+            nonlocal link_count
+            lat = (
+                vlink_latency
+                if (
+                    ("Up" in src_port)
+                    or ("Down" in src_port)
+                    or ("Up" in dst_port)
+                    or ("Down" in dst_port)
+                )
+                else link_latency
+            )
+            int_links.append(
+                IntLink(
+                    link_id=link_count,
+                    src_node=routers[src_id],
+                    dst_node=routers[dst_id],
+                    src_outport=src_port,
+                    dst_inport=dst_port,
+                    latency=lat,
+                    weight=w,
+                )
+            )
+            link_count += 1
+
+        for z in range(Z):
+            # chiplet
+            cz = z // CHIP_Z
+            for y in range(Y):
+                cy = y // CHIP_Y
+                for x in range(X):
+                    cx = x // CHIP_X
+
+                    # East-West
+                    if (x + 1 < X) and ((x + 1) // CHIP_X == cx):
+                        a = self._rid(x, y, z, X, Y)
+                        b = self._rid(x + 1, y, z, X, Y)
+                        add_link(a, b, "East", "West", W_INTRA)
+                        add_link(b, a, "West", "East", W_INTRA)
+
+                    # North-South
+                    if (y + 1 < Y) and ((y + 1) // CHIP_Y == cy):
+                        a = self._rid(x, y, z, X, Y)
+                        b = self._rid(x, y + 1, z, X, Y)
+                        add_link(a, b, "North", "South", W_INTRA)
+                        add_link(b, a, "South", "North", W_INTRA)
+
+                    # Up-Down
+                    if (z + 1 < Z) and ((z + 1) // CHIP_Z == cz):
+                        a = self._rid(x, y, z, X, Y)
+                        b = self._rid(x, y, z + 1, X, Y)
+                        add_link(a, b, "Up", "Down", W_INTRA)
+                        add_link(b, a, "Down", "Up", W_INTRA)
+
+        #   X  chiplet
+        for cz in range(CZ):
+            for cy in range(CY):
+                for cx in range(CX - 1):
+                    gx0, gy0, gz0 = gw_x_map[(cx, cy, cz)]
+                    gx1, gy1, gz1 = gw_x_map[(cx + 1, cy, cz)]
+                    a = self._rid(gx0, gy0, gz0, X, Y)
+                    b = self._rid(gx1, gy1, gz1, X, Y)
+                    add_link(a, b, "EastGW", "WestGW", W_BACKBONE)
+                    add_link(b, a, "WestGW", "EastGW", W_BACKBONE)
+
+        #   Y  chiplet
+        for cz in range(CZ):
+            for cy in range(CY - 1):
+                for cx in range(CX):
+                    gx0, gy0, gz0 = gw_y_map[(cx, cy, cz)]
+                    gx1, gy1, gz1 = gw_y_map[(cx, cy + 1, cz)]
+                    a = self._rid(gx0, gy0, gz0, X, Y)
+                    b = self._rid(gx1, gy1, gz1, X, Y)
+                    add_link(a, b, "NorthGW", "SouthGW", W_BACKBONE)
+                    add_link(b, a, "SouthGW", "NorthGW", W_BACKBONE)
+
+        #   Z  chiplet
+
+        for cz in range(CZ - 1):
+            for cy in range(CY):
+                for cx in range(CX):
+                    gx0, gy0, gz0 = gw_x_map[(cx, cy, cz)]
+                    gx1, gy1, gz1 = gw_x_map[(cx, cy, cz + 1)]
+                    a = self._rid(gx0, gy0, gz0, X, Y)
+                    b = self._rid(gx1, gy1, gz1, X, Y)
+                    add_link(a, b, "UpGW", "DownGW", W_VERTICAL)
+                    add_link(b, a, "DownGW", "UpGW", W_VERTICAL)
+
+        network.int_links = int_links
+
+    def registerTopology(self, options):
+        for i in range(options.num_cpus):
+            FileSystemConfig.register_node(
+                [i], MemorySize(options.mem_size) // options.num_cpus, i
+            )
diff --git a/configs/topologies/Hier3D_ClusterHub.py b/configs/topologies/Hier3D_ClusterHub.py
new file mode 100644
index 0000000000..ccc962d210
--- /dev/null
+++ b/configs/topologies/Hier3D_ClusterHub.py
@@ -0,0 +1,252 @@
+# configs/topologies/Hier3D_ClusterHub.py
+
+from m5.params import *
+from m5.objects import *
+
+from common import FileSystemConfig
+from topologies.BaseTopology import SimpleTopology
+
+
+class Hier3D_ClusterHub(SimpleTopology):
+    description = "Hier3D_ClusterHub"
+
+    # Config knobs
+    HUB_SPEEDUP = (
+        2  # hub router latency = max(1, router_latency // HUB_SPEEDUP)
+    )
+    CLUSTER_SIDE = 2  # 2x2 HRs per hub
+
+    def __init__(self, controllers):
+        self.nodes = controllers
+
+    def makeTopology(self, options, network, IntLink, ExtLink, Router):
+        nodes = self.nodes
+
+        # Geometry: use mesh_rows for X=Y, derive Z from num_cpus/(X*Y)
+        X = int(options.mesh_rows)
+        Y = int(options.mesh_rows)
+        assert (
+            X > 0 and Y > 0 and X == Y
+        ), "Require square per-layer grid (X == Y)"
+
+        N_HR = int(
+            options.num_cpus
+        )  # number of horizontal routers (one per tile)
+        assert (
+            N_HR % (X * Y)
+        ) == 0, "num_cpus must be divisible by X*Y to get integer Z"
+        Z = N_HR // (X * Y)
+        assert Z > 0, "Z must be > 0"
+
+        # Cluster grid per layer (2x2 HRs -> 1 hub)
+        assert (
+            X % self.CLUSTER_SIDE == 0 and Y % self.CLUSTER_SIDE == 0
+        ), "X and Y must be multiples of CLUSTER_SIDE"
+        CX = X // self.CLUSTER_SIDE
+        CY = Y // self.CLUSTER_SIDE
+        hubs_per_layer = CX * CY
+        N_HBR = Z * hubs_per_layer
+
+        # Latencies
+        link_latency = int(options.link_latency)
+        router_latency = int(options.router_latency)
+
+        # TSV controls for vertical (Z) links
+        tsv_slow = max(1, int(getattr(options, "tsv_slowdown", 4)))
+        tsv_fast = max(1, int(getattr(options, "tsv_speedup", 1)))
+        vlink_latency = max(1, int(link_latency) * tsv_slow // tsv_fast)
+
+        hub_latency = max(1, router_latency // max(1, self.HUB_SPEEDUP))
+
+        # ID helpers: first N_HR are HRs, then hubs
+        def hr_id(x, y, z):
+            return z * (X * Y) + y * X + x
+
+        def hub_id(cx, cy, z):
+            return N_HR + z * (CX * CY) + cy * CX + cx
+
+        # Create routers: HRs with router_latency, HBRs with hub_latency
+        routers = []
+        for i in range(N_HR):
+            routers.append(Router(router_id=i, latency=router_latency))
+        for j in range(N_HBR):
+            routers.append(Router(router_id=N_HR + j, latency=hub_latency))
+        network.routers = routers
+
+        # External links: map controllers uniformly to HRs; remainder to router 0 (DMA)
+        ext_links = []
+        link_id = 0
+        cntrls_per_router, remainder = divmod(len(nodes), N_HR)
+        network_nodes = nodes[: len(nodes) - remainder]
+        remainder_nodes = nodes[len(nodes) - remainder :]
+
+        for i, n in enumerate(network_nodes):
+            level, rid = divmod(i, N_HR)
+            assert level < cntrls_per_router
+            ext_links.append(
+                ExtLink(
+                    link_id=link_id,
+                    ext_node=n,
+                    int_node=routers[rid],
+                    latency=link_latency,
+                )
+            )
+            link_id += 1
+
+        for i, n in enumerate(remainder_nodes):
+            assert n.type == "DMA_Controller" and i < remainder
+            ext_links.append(
+                ExtLink(
+                    link_id=link_id,
+                    ext_node=n,
+                    int_node=routers[0],
+                    latency=link_latency,
+                )
+            )
+            link_id += 1
+
+        network.ext_links = ext_links
+
+        int_links = []
+
+        # Weights for DOR-friendly ordering on the hub backbone
+        WX, WY, WZ = 1, 2, 3
+
+        # (A) HR <-> HBR: star within each 2x2 cluster (bidirectional)
+        #     Weight = 1 (local egress/ingress to hub)
+        for z in range(Z):
+            for y in range(Y):
+                for x in range(X):
+                    cx, cy = x // self.CLUSTER_SIDE, y // self.CLUSTER_SIDE
+                    h = hr_id(x, y, z)
+                    hub = hub_id(cx, cy, z)
+                    int_links.append(
+                        IntLink(
+                            link_id=link_id,
+                            src_node=routers[h],
+                            dst_node=routers[hub],
+                            src_outport="ToHub",
+                            dst_inport="FromCluster",
+                            latency=link_latency,
+                            weight=1,
+                        )
+                    )
+                    link_id += 1
+                    int_links.append(
+                        IntLink(
+                            link_id=link_id,
+                            src_node=routers[hub],
+                            dst_node=routers[h],
+                            src_outport="ToCluster",
+                            dst_inport="FromHub",
+                            latency=link_latency,
+                            weight=1,
+                        )
+                    )
+                    link_id += 1
+
+        # (B) HBR <-> HBR: 3D mesh among hubs (only hubs connect horizontally/vertically)
+        # X dimension (East/West): weight=WX, latency=link_latency
+        for z in range(Z):
+            for cy in range(CY):
+                for cx in range(CX - 1):
+                    a = hub_id(cx, cy, z)
+                    b = hub_id(cx + 1, cy, z)
+                    # a -> b (East), b -> a (West)
+                    int_links.append(
+                        IntLink(
+                            link_id=link_id,
+                            src_node=routers[a],
+                            dst_node=routers[b],
+                            src_outport="East",
+                            dst_inport="West",
+                            latency=link_latency,
+                            weight=WX,
+                        )
+                    )
+                    link_id += 1
+                    int_links.append(
+                        IntLink(
+                            link_id=link_id,
+                            src_node=routers[b],
+                            dst_node=routers[a],
+                            src_outport="West",
+                            dst_inport="East",
+                            latency=link_latency,
+                            weight=WX,
+                        )
+                    )
+                    link_id += 1
+
+        # Y dimension (North/South): weight=WY, latency=link_latency
+        for z in range(Z):
+            for cx in range(CX):
+                for cy in range(CY - 1):
+                    a = hub_id(cx, cy, z)
+                    b = hub_id(cx, cy + 1, z)
+                    # a -> b (North), b -> a (South)
+                    int_links.append(
+                        IntLink(
+                            link_id=link_id,
+                            src_node=routers[a],
+                            dst_node=routers[b],
+                            src_outport="North",
+                            dst_inport="South",
+                            latency=link_latency,
+                            weight=WY,
+                        )
+                    )
+                    link_id += 1
+                    int_links.append(
+                        IntLink(
+                            link_id=link_id,
+                            src_node=routers[b],
+                            dst_node=routers[a],
+                            src_outport="South",
+                            dst_inport="North",
+                            latency=link_latency,
+                            weight=WY,
+                        )
+                    )
+                    link_id += 1
+
+        # Z dimension (Up/Down): weight=WZ, latency=vlink_latency
+        for cy in range(CY):
+            for cx in range(CX):
+                for z in range(Z - 1):
+                    a = hub_id(cx, cy, z)
+                    b = hub_id(cx, cy, z + 1)
+                    # a -> b (Up), b -> a (Down)
+                    int_links.append(
+                        IntLink(
+                            link_id=link_id,
+                            src_node=routers[a],
+                            dst_node=routers[b],
+                            src_outport="Up",
+                            dst_inport="Down",
+                            latency=vlink_latency,
+                            weight=WZ,
+                        )
+                    )
+                    link_id += 1
+                    int_links.append(
+                        IntLink(
+                            link_id=link_id,
+                            src_node=routers[b],
+                            dst_node=routers[a],
+                            src_outport="Down",
+                            dst_inport="Up",
+                            latency=vlink_latency,
+                            weight=WZ,
+                        )
+                    )
+                    link_id += 1
+
+        network.int_links = int_links
+
+    # Register nodes with filesystem
+    def registerTopology(self, options):
+        for i in range(options.num_cpus):
+            FileSystemConfig.register_node(
+                [i], MemorySize(options.mem_size) // options.num_cpus, i
+            )
diff --git a/configs/topologies/Mesh3D_XYZ.py b/configs/topologies/Mesh3D_XYZ.py
new file mode 100644
index 0000000000..287ff2ede8
--- /dev/null
+++ b/configs/topologies/Mesh3D_XYZ.py
@@ -0,0 +1,210 @@
+# Mesh3D_XYZ topology for gem5
+
+from m5.params import *
+from m5.objects import *
+
+from common import FileSystemConfig
+
+from topologies.BaseTopology import SimpleTopology
+
+# 4x4x4 3D Mesh (no wrap). Port names follow Mesh_XY style:
+# +X: East, -X: West; +Y: North, -Y: South; +Z: Up, -Z: Down.
+# File name distinguishes it as the topology we use with XYZ routing.
+
+
+class Mesh3D_XYZ(SimpleTopology):
+    description = "Mesh3D_XYZ"
+
+    def __init__(self, controllers):
+        self.nodes = controllers
+
+    # Build a 4x4x4 mesh (64 routers). Compatible with both TABLE_ (0) and XYZ_ (3).
+    def makeTopology(self, options, network, IntLink, ExtLink, Router):
+        nodes = self.nodes
+
+        num_routers = options.num_cpus
+        num_rows = options.mesh_rows  # keep the same interface as Mesh_XY
+
+        # default values for link latency and router latency.
+        link_latency = options.link_latency  # used by simple and garnet
+        router_latency = options.router_latency  # only used by garnet
+
+        # TSV (Through-Silicon Via) latency for Z-axis links
+        # Z latency = link_latency * tsv_slowdown / tsv_speedup
+        tsv_slowdown = max(1, int(getattr(options, "tsv_slowdown", 4)))
+        tsv_speedup = max(1, int(getattr(options, "tsv_speedup", 1)))
+        tsv_latency = max(1, int(link_latency) * tsv_slowdown // tsv_speedup)
+
+        # Fixed geometry: 4x4x4
+        X, Y, Z = 4, 4, 4
+        assert num_rows > 0
+        assert num_routers == X * Y * Z, "Mesh3D_XYZ_ requires --num-cpus=64"
+        assert num_rows == Y, "Mesh3D_XYZ_ requires --mesh-rows=4"
+
+        # There must be an evenly divisible number of cntrls to routers
+        cntrls_per_router, remainder = divmod(len(nodes), num_routers)
+
+        # Create the routers in the 3D mesh
+        routers = [
+            Router(router_id=i, latency=router_latency)
+            for i in range(num_routers)
+        ]
+        network.routers = routers
+
+        # link counter to set unique link ids
+        link_count = 0
+
+        # Distribute controllers uniformly across routers (same as Mesh_XY)
+        network_nodes = []
+        remainder_nodes = []
+        for node_index in range(len(nodes)):
+            if node_index < (len(nodes) - remainder):
+                network_nodes.append(nodes[node_index])
+            else:
+                remainder_nodes.append(nodes[node_index])
+
+        # Connect each node to the appropriate router (uniform)
+        ext_links = []
+        for (i, n) in enumerate(network_nodes):
+            cntrl_level, router_id = divmod(i, num_routers)
+            assert cntrl_level < cntrls_per_router
+            ext_links.append(
+                ExtLink(
+                    link_id=link_count,
+                    ext_node=n,
+                    int_node=routers[router_id],
+                    latency=link_latency,
+                )
+            )
+            link_count += 1
+
+        # Connect the remaining nodes to router 0. These should only be DMA nodes.
+        for (i, node) in enumerate(remainder_nodes):
+            assert node.type == "DMA_Controller"
+            assert i < remainder
+            ext_links.append(
+                ExtLink(
+                    link_id=link_count,
+                    ext_node=node,
+                    int_node=routers[0],
+                    latency=link_latency,
+                )
+            )
+            link_count += 1
+
+        network.ext_links = ext_links
+
+        # Create the 3D mesh internal links (bidirectional)
+        int_links = []
+
+        # Helper: linear index z*(X*Y) + y*X + x (must match C++ routing's decode)
+        def idx(x, y, z):
+            return z * (X * Y) + y * X + x
+
+        # Weights: follow Mesh_XY style. X=1, Y=2; use Z=3.
+        WX, WY, WZ = 1, 2, 3
+
+        # +X / -X (weight = 1)
+        for z in range(Z):
+            for y in range(Y):
+                for x in range(X - 1):
+                    a = idx(x, y, z)
+                    b = idx(x + 1, y, z)
+                    # a -> b : East, b -> a : West
+                    int_links.append(
+                        IntLink(
+                            link_id=link_count,
+                            src_node=routers[a],
+                            dst_node=routers[b],
+                            src_outport="East",
+                            dst_inport="West",
+                            latency=link_latency,
+                            weight=WX,
+                        )
+                    )
+                    link_count += 1
+                    int_links.append(
+                        IntLink(
+                            link_id=link_count,
+                            src_node=routers[b],
+                            dst_node=routers[a],
+                            src_outport="West",
+                            dst_inport="East",
+                            latency=link_latency,
+                            weight=WX,
+                        )
+                    )
+                    link_count += 1
+
+        # +Y / -Y (weight = 2) — +Y uses "North", -Y uses "South" (Mesh_XY convention)
+        for z in range(Z):
+            for x in range(X):
+                for y in range(Y - 1):
+                    a = idx(x, y, z)
+                    b = idx(x, y + 1, z)
+                    # a -> b : North, b -> a : South
+                    int_links.append(
+                        IntLink(
+                            link_id=link_count,
+                            src_node=routers[a],
+                            dst_node=routers[b],
+                            src_outport="North",
+                            dst_inport="South",
+                            latency=link_latency,
+                            weight=WY,
+                        )
+                    )
+                    link_count += 1
+                    int_links.append(
+                        IntLink(
+                            link_id=link_count,
+                            src_node=routers[b],
+                            dst_node=routers[a],
+                            src_outport="South",
+                            dst_inport="North",
+                            latency=link_latency,
+                            weight=WY,
+                        )
+                    )
+                    link_count += 1
+
+        # +Z / -Z (weight = 3) - Using TSV latency (slower than horizontal links)
+        for y in range(Y):
+            for x in range(X):
+                for z in range(Z - 1):
+                    a = idx(x, y, z)
+                    b = idx(x, y, z + 1)
+                    # a -> b : Up, b -> a : Down
+                    int_links.append(
+                        IntLink(
+                            link_id=link_count,
+                            src_node=routers[a],
+                            dst_node=routers[b],
+                            src_outport="Up",
+                            dst_inport="Down",
+                            latency=tsv_latency,
+                            weight=WZ,
+                        )
+                    )
+                    link_count += 1
+                    int_links.append(
+                        IntLink(
+                            link_id=link_count,
+                            src_node=routers[b],
+                            dst_node=routers[a],
+                            src_outport="Down",
+                            dst_inport="Up",
+                            latency=tsv_latency,
+                            weight=WZ,
+                        )
+                    )
+                    link_count += 1
+
+        network.int_links = int_links
+
+    # Register nodes with filesystem (same as Mesh_XY)
+    def registerTopology(self, options):
+        for i in range(options.num_cpus):
+            FileSystemConfig.register_node(
+                [i], MemorySize(options.mem_size) // options.num_cpus, i
+            )
diff --git a/configs/topologies/Sparse3D_Pillars.py b/configs/topologies/Sparse3D_Pillars.py
new file mode 100644
index 0000000000..a852f8841d
--- /dev/null
+++ b/configs/topologies/Sparse3D_Pillars.py
@@ -0,0 +1,248 @@
+# configs/topologies/Sparse3D_Pillars.py
+
+from m5.params import *
+from m5.objects import *
+
+from common import FileSystemConfig
+from topologies.BaseTopology import SimpleTopology
+
+
+class Sparse3D_Pillars(SimpleTopology):
+    description = "Sparse3D_Pillars"
+
+    def __init__(self, controllers):
+        self.nodes = controllers
+
+    def makeTopology(self, options, network, IntLink, ExtLink, Router):
+        nodes = self.nodes
+        num_routers = options.num_cpus
+        num_rows = options.mesh_rows
+
+        # ----- Configuration Parameters -----
+        PX, PY = 2, 2
+        LAYOUT_MODE = "aligned"
+        WXP, WYP, WZP = 1, 2, 3
+        WXN, WYN, WZN = 1, 2, 3
+        X, Y, Z = 4, 4, 4
+
+        # SLOWDOWN: k>=1
+        # SPEEDUP:  m>=1
+        V_SLOWDOWN = max(1, int(getattr(options, "tsv_slowdown", 4)))
+        V_SPEEDUP = max(1, int(getattr(options, "tsv_speedup", 1)))
+
+        # ----- Configuration Parameters -----
+
+        assert (
+            num_routers == X * Y * Z
+        ), f"Sparse3D_Pillars requires --num-cpus={X*Y*Z}"
+        assert num_rows == Y, f"Sparse3D_Pillars requires --mesh-rows={Y}"
+        if LAYOUT_MODE == "staggered":
+            assert (
+                PX % 2 == 0 and PY % 2 == 0
+            ), "Staggered layout requires even spacing"
+
+        def _is_pillar_xy(x, y):
+            return (x % max(1, PX) == 0) and (y % max(1, PY) == 0)
+
+        def _idx(x, y, z):
+            return z * (X * Y) + y * X + x
+
+        def nearest_pillar_xy(x, y):
+
+            px = round(x / PX) * PX
+            py = round(y / PY) * PY
+
+            px = max(0, min(X - 1, px))
+            py = max(0, min(Y - 1, py))
+            return px, py
+
+        def dist_to_pillar(x, y):
+            px, py = nearest_pillar_xy(x, y)
+            return abs(x - px) + abs(y - py)
+
+        # ----- Link Latencies -----
+        link_latency = options.link_latency
+
+        vlink_latency = max(
+            1, int(link_latency) * V_SLOWDOWN // max(1, V_SPEEDUP)
+        )
+        router_latency = options.router_latency
+
+        # ----- Router Creation -----
+        cntrls_per_router, remainder = divmod(len(nodes), num_routers)
+
+        routers = [
+            Router(router_id=i, latency=router_latency)
+            for i in range(num_routers)
+        ]
+        network.routers = routers
+
+        link_count = 0
+
+        # ----- External Links -----
+
+        network_nodes = []
+        remainder_nodes = []
+        for node_index in range(len(nodes)):
+            if node_index < (len(nodes) - remainder):
+                network_nodes.append(nodes[node_index])
+            else:
+                remainder_nodes.append(nodes[node_index])
+
+        # Connect external nodes (CPUs, etc.) to routers
+        ext_links = []
+        for (i, n) in enumerate(network_nodes):
+            cntrl_level, router_id = divmod(i, num_routers)
+            assert cntrl_level < cntrls_per_router
+            ext_links.append(
+                ExtLink(
+                    link_id=link_count,
+                    ext_node=n,
+                    int_node=routers[router_id],
+                    latency=link_latency,
+                )
+            )
+            link_count += 1
+
+        # Connect the remaining nodes to router 0. These should only be DMA nodes.
+        for (i, node) in enumerate(remainder_nodes):
+            assert node.type == "DMA_Controller"
+            assert i < remainder
+            ext_links.append(
+                ExtLink(
+                    link_id=link_count,
+                    ext_node=node,
+                    int_node=routers[0],
+                    latency=link_latency,
+                )
+            )
+            link_count += 1
+
+        network.ext_links = ext_links
+
+        # ----- Internal Links -----
+        int_links = []
+
+        for z in range(Z):
+            for y in range(Y):
+                for x in range(X - 1):
+                    a = _idx(x, y, z)
+                    b = _idx(x + 1, y, z)
+
+                    int_links.append(
+                        IntLink(
+                            link_id=link_count,
+                            src_node=routers[a],
+                            dst_node=routers[b],
+                            src_outport="East",
+                            dst_inport="West",
+                            latency=link_latency,
+                            weight=WXP,
+                        )
+                    )
+                    link_count += 1
+                    int_links.append(
+                        IntLink(
+                            link_id=link_count,
+                            src_node=routers[b],
+                            dst_node=routers[a],
+                            src_outport="West",
+                            dst_inport="East",
+                            latency=link_latency,
+                            weight=WXN,
+                        )
+                    )
+                    link_count += 1
+
+        for z in range(Z):
+            for x in range(X):
+                for y in range(Y - 1):
+                    a = _idx(x, y, z)
+                    b = _idx(x, y + 1, z)
+                    # w_ab = W_TOWARD if dist_to_pillar(x, y + 1) < dist_to_pillar(x, y) else W_AWAY
+                    # w_ba = W_TOWARD if dist_to_pillar(x, y) < dist_to_pillar(x, y + 1) else W_AWAY
+                    int_links.append(
+                        IntLink(
+                            link_id=link_count,
+                            src_node=routers[a],
+                            dst_node=routers[b],
+                            src_outport="North",
+                            dst_inport="South",
+                            latency=link_latency,
+                            weight=WYP,
+                        )
+                    )
+                    link_count += 1
+                    int_links.append(
+                        IntLink(
+                            link_id=link_count,
+                            src_node=routers[b],
+                            dst_node=routers[a],
+                            src_outport="South",
+                            dst_inport="North",
+                            latency=link_latency,
+                            weight=WYN,
+                        )
+                    )
+                    link_count += 1
+
+        int_links_z = []
+        for z in range(Z - 1):
+            for y in range(Y):
+                for x in range(X):
+                    is_pillar_location = False
+                    if LAYOUT_MODE == "aligned":
+                        if x % PX == 0 and y % PY == 0:
+                            is_pillar_location = True
+                    elif LAYOUT_MODE == "staggered":
+
+                        if z % 2 == 0:
+                            if x % PX == 0 and y % PY == 0:
+                                is_pillar_location = True
+
+                        else:  # z is odd
+                            if (x + PX // 2) % PX == 0 and (
+                                y + PY // 2
+                            ) % PY == 0:
+                                is_pillar_location = True
+                    else:
+                        raise ValueError(
+                            f"Invalid layout specified: {LAYOUT_MODE}"
+                        )
+
+                    if is_pillar_location:
+                        a = _idx(x, y, z)
+                        b = _idx(x, y, z + 1)
+                        int_links_z.append(
+                            IntLink(
+                                link_id=link_count,
+                                src_node=routers[a],
+                                dst_node=routers[b],
+                                src_outport="Up",
+                                dst_inport="Down",
+                                latency=vlink_latency,
+                                weight=WZN,
+                            )
+                        )
+                        link_count += 1
+                        int_links_z.append(
+                            IntLink(
+                                link_id=link_count,
+                                src_node=routers[b],
+                                dst_node=routers[a],
+                                src_outport="Down",
+                                dst_inport="Up",
+                                latency=vlink_latency,
+                                weight=WZP,
+                            )
+                        )
+                        link_count += 1
+
+        int_links.extend(int_links_z)
+        network.int_links = int_links
+
+    def registerTopology(self, options):
+        for i in range(options.num_cpus):
+            FileSystemConfig.register_node(
+                [i], MemorySize(options.mem_size) // options.num_cpus, i
+            )
diff --git a/configs/topologies/Sparse3D_Pillars_torus.py b/configs/topologies/Sparse3D_Pillars_torus.py
new file mode 100644
index 0000000000..450363d9d3
--- /dev/null
+++ b/configs/topologies/Sparse3D_Pillars_torus.py
@@ -0,0 +1,202 @@
+# Sparse-Vertical 3D (Pillar-based) topology with Torus links for Garnet 3.0
+
+from m5.params import *
+from m5.objects import *
+
+from common import FileSystemConfig
+from topologies.BaseTopology import SimpleTopology
+
+
+class Sparse3D_Pillars_torus(SimpleTopology):
+    description = "Sparse3D_Pillars_torus"
+
+    def __init__(self, controllers):
+        self.nodes = controllers
+
+    def makeTopology(self, options, network, IntLink, ExtLink, Router):
+        nodes = self.nodes
+        num_routers = options.num_cpus
+        num_rows = options.mesh_rows
+
+        # ----- Configuration Parameters -----
+        PX, PY = 2, 2
+        LAYOUT_MODE = "aligned"
+        WXP, WYP, WZP = 1, 2, 3
+        WXN, WYN, WZN = 1, 2, 3
+        X, Y, Z = 4, 4, 4
+        # TSV latency multiplier and optional parallel links (sparse-only)
+        V_SLOWDOWN = max(1, int(getattr(options, "tsv_slowdown", 4)))
+        V_SPEEDUP = max(1, int(getattr(options, "tsv_speedup", 1)))
+        # ------------------------------------
+
+        assert (
+            num_routers == X * Y * Z
+        ), f"Sparse3D_Pillars_torus requires --num-cpus={X*Y*Z}"
+        assert num_rows == Y, f"Sparse3D_Pillars_torus requires --mesh-rows={Y}"
+        if LAYOUT_MODE == "staggered":
+            assert (
+                PX % 2 == 0 and PY % 2 == 0
+            ), "Staggered layout requires even spacing"
+
+        # ----- Helper Functions -----
+        def _idx(x, y, z):
+            return z * (X * Y) + y * X + x
+
+        # ----- Link Latencies -----
+        link_latency = options.link_latency
+        vlink_latency = max(1, int(link_latency) * V_SLOWDOWN // max(1, V_SPEEDUP))
+        router_latency = options.router_latency
+
+        # ----- Router Creation -----
+        routers = [
+            Router(router_id=i, latency=router_latency)
+            for i in range(num_routers)
+        ]
+        network.routers = routers
+
+        link_count = 0
+
+        # ----- External Links -----
+        ext_links = []
+        cntrls_per_router, remainder = divmod(len(nodes), num_routers)
+        network_nodes = nodes[: len(nodes) - remainder]
+        remainder_nodes = nodes[len(nodes) - remainder :]
+        for (i, n) in enumerate(network_nodes):
+            cntrl_level, router_id = divmod(i, num_routers)
+            assert cntrl_level < cntrls_per_router
+            ext_links.append(
+                ExtLink(
+                    link_id=link_count,
+                    ext_node=n,
+                    int_node=routers[router_id],
+                    latency=link_latency,
+                )
+            )
+            link_count += 1
+
+        for (i, node) in enumerate(remainder_nodes):
+            assert node.type == "DMA_Controller"
+            assert i < remainder
+            ext_links.append(
+                ExtLink(
+                    link_id=link_count,
+                    ext_node=node,
+                    int_node=routers[0],
+                    latency=link_latency,
+                )
+            )
+            link_count += 1
+        network.ext_links = ext_links
+
+        # ----- Internal Links -----
+        int_links = []
+
+        # East-West (+X / -X) links with wraparound
+        for z in range(Z):
+            for y in range(Y):
+                for x in range(X):
+                    a = _idx(x, y, z)
+                    b = _idx((x + 1) % X, y, z)
+                    int_links.append(
+                        IntLink(
+                            link_id=link_count,
+                            src_node=routers[a],
+                            dst_node=routers[b],
+                            src_outport="East",
+                            dst_inport="West",
+                            latency=link_latency,
+                            weight=WXP,
+                        )
+                    )
+                    link_count += 1
+                    int_links.append(
+                        IntLink(
+                            link_id=link_count,
+                            src_node=routers[b],
+                            dst_node=routers[a],
+                            src_outport="West",
+                            dst_inport="East",
+                            latency=link_latency,
+                            weight=WXN,
+                        )
+                    )
+                    link_count += 1
+
+        # North-South (+Y / -Y) links with wraparound
+        for z in range(Z):
+            for x in range(X):
+                for y in range(Y):
+                    a = _idx(x, y, z)
+                    b = _idx(x, (y + 1) % Y, z)
+                    int_links.append(
+                        IntLink(
+                            link_id=link_count,
+                            src_node=routers[a],
+                            dst_node=routers[b],
+                            src_outport="North",
+                            dst_inport="South",
+                            latency=link_latency,
+                            weight=WYP,
+                        )
+                    )
+                    link_count += 1
+                    int_links.append(
+                        IntLink(
+                            link_id=link_count,
+                            src_node=routers[b],
+                            dst_node=routers[a],
+                            src_outport="South",
+                            dst_inport="North",
+                            latency=link_latency,
+                            weight=WYN,
+                        )
+                    )
+                    link_count += 1
+
+        # Z-links (Up/Down) only on pillars, with wraparound; single link with adjusted latency
+        for y in range(Y):
+            for x in range(X):
+                is_pillar_location = False
+                if LAYOUT_MODE == "aligned":
+                    if x % PX == 0 and y % PY == 0:
+                        is_pillar_location = True
+                elif LAYOUT_MODE == "staggered":
+                    if x % PX == 0 and y % PY == 0:
+                        is_pillar_location = True
+
+                if is_pillar_location:
+                    for z in range(Z):
+                        a = _idx(x, y, z)
+                        b = _idx(x, y, (z + 1) % Z)
+                        int_links.append(
+                            IntLink(
+                                link_id=link_count,
+                                src_node=routers[a],
+                                dst_node=routers[b],
+                                src_outport="Up",
+                                dst_inport="Down",
+                                latency=vlink_latency,
+                                weight=WZP,
+                            )
+                        )
+                        link_count += 1
+                        int_links.append(
+                            IntLink(
+                                link_id=link_count,
+                                src_node=routers[b],
+                                dst_node=routers[a],
+                                src_outport="Down",
+                                dst_inport="Up",
+                                latency=vlink_latency,
+                                weight=WZN,
+                            )
+                        )
+                        link_count += 1
+
+        network.int_links = int_links
+
+    def registerTopology(self, options):
+        for i in range(options.num_cpus):
+            FileSystemConfig.register_node(
+                [i], MemorySize(options.mem_size) // options.num_cpus, i
+            )
diff --git a/configs/topologies/Torus3D.py b/configs/topologies/Torus3D.py
new file mode 100644
index 0000000000..8e45212ab2
--- /dev/null
+++ b/configs/topologies/Torus3D.py
@@ -0,0 +1,111 @@
+# Torus3D  topology for Garnet 3.0
+
+from m5.params import *
+from m5.objects import *
+
+from common import FileSystemConfig
+from topologies.BaseTopology import SimpleTopology
+
+class Torus3D(SimpleTopology):
+    description = "Torus3D"
+
+    def __init__(self, controllers):
+        self.nodes = controllers
+
+    def makeTopology(self, options, network, IntLink, ExtLink, Router):
+        nodes = self.nodes
+
+        num_routers = options.num_cpus
+        num_rows = options.mesh_rows
+
+        # Fixed geometry: 4x4x4
+        X, Y, Z = 4, 4, 4
+        assert num_rows > 0
+        assert num_routers == X * Y * Z, "Torus3D requires --num-cpus=64"
+        assert num_rows == Y, "Torus3D requires --mesh-rows=4"
+
+        # default values for link latency and router latency.
+        link_latency = options.link_latency
+        router_latency = options.router_latency
+        # Z-link (TSV) latency = link_latency * SLOWDOWN / SPEEDUP
+        tsv_slowdown = max(1, int(getattr(options, "tsv_slowdown", 4)))
+        tsv_speedup = max(1, int(getattr(options, "tsv_speedup", 1)))
+        vlink_latency = max(1, int(link_latency) * tsv_slowdown // tsv_speedup)
+
+        # Create the routers
+        routers = [Router(router_id=i, latency=router_latency) for i in range(num_routers)]
+        network.routers = routers
+
+        # link counter
+        link_count = 0
+
+        # Connect controllers to routers
+        cntrls_per_router, remainder = divmod(len(nodes), num_routers)
+
+        network_nodes = nodes[:len(nodes) - remainder]
+        remainder_nodes = nodes[len(nodes) - remainder:]
+
+        ext_links = []
+        for (i, n) in enumerate(network_nodes):
+            cntrl_level, router_id = divmod(i, num_routers)
+            assert cntrl_level < cntrls_per_router
+            ext_links.append(ExtLink(link_id=link_count, ext_node=n, int_node=routers[router_id], latency=link_latency))
+            link_count += 1
+
+        for (i, node) in enumerate(remainder_nodes):
+            assert node.type == 'DMA_Controller'
+            ext_links.append(ExtLink(link_id=link_count, ext_node=node, int_node=routers[0], latency=link_latency))
+            link_count += 1
+
+        network.ext_links = ext_links
+
+        # Create the torus links
+        int_links = []
+
+        def idx(x, y, z):
+            return z * (X * Y) + y * X + x
+
+        # Weights for routing.
+        WX, WY, WZ = 1, 2, 3
+
+        # East-West links (X dimension) with wraparound
+        for z in range(Z):
+            for y in range(Y):
+                for x in range(X):
+                    left_node = idx(x, y, z)
+                    right_node = idx((x + 1) % X, y, z)
+
+                    int_links.append(IntLink(link_id=link_count, src_node=routers[left_node], dst_node=routers[right_node], src_outport="East", dst_inport="West", latency=link_latency, weight=WX))
+                    link_count += 1
+                    int_links.append(IntLink(link_id=link_count, src_node=routers[right_node], dst_node=routers[left_node], src_outport="West", dst_inport="East", latency=link_latency, weight=WX))
+                    link_count += 1
+
+        # North-South links (Y dimension) with wraparound
+        for z in range(Z):
+            for x in range(X):
+                for y in range(Y):
+                    up_node = idx(x, y, z)
+                    down_node = idx(x, (y + 1) % Y, z)
+                    int_links.append(IntLink(link_id=link_count, src_node=routers[up_node], dst_node=routers[down_node], src_outport="North", dst_inport="South", latency=link_latency, weight=WY))
+                    link_count += 1
+                    int_links.append(IntLink(link_id=link_count, src_node=routers[down_node], dst_node=routers[up_node], src_outport="South", dst_inport="North", latency=link_latency, weight=WY))
+                    link_count += 1
+
+        # Up-Down links (Z dimension) with wraparound (TSV slower)
+        for y in range(Y):
+            for x in range(X):
+                for z in range(Z):
+                    front_node = idx(x, y, z)
+                    back_node = idx(x, y, (z + 1) % Z)
+                    int_links.append(IntLink(link_id=link_count, src_node=routers[front_node], dst_node=routers[back_node], src_outport="Up", dst_inport="Down", latency=vlink_latency, weight=WZ))
+                    link_count += 1
+                    int_links.append(IntLink(link_id=link_count, src_node=routers[back_node], dst_node=routers[front_node], src_outport="Down", dst_inport="Up", latency=vlink_latency, weight=WZ))
+                    link_count += 1
+
+        network.int_links = int_links
+
+    def registerTopology(self, options):
+        for i in range(options.num_cpus):
+            FileSystemConfig.register_node(
+                [i], MemorySize(options.mem_size) // options.num_cpus, i
+            )
diff --git a/integrate.sh b/integrate.sh
new file mode 100644
index 0000000000..044ae9bb3f
--- /dev/null
+++ b/integrate.sh
@@ -0,0 +1,3 @@
+bash run_routing.sh
+bash run_zlink.sh
+bash run_topo.sh
diff --git a/network_stats.txt b/network_stats.txt
new file mode 100644
index 0000000000..0b1a68d12d
--- /dev/null
+++ b/network_stats.txt
@@ -0,0 +1,7 @@
+
+packets_injected = 2325                       (Unspecified)
+packets_received = 1505                       (Unspecified)
+average_packet_queueing_latency = 8.374751                       (Unspecified)
+average_packet_network_latency = 35.291030                       (Unspecified)
+average_packet_latency = 43.665781                       (Unspecified)
+average_hops = 3.073754                       (Unspecified)
diff --git a/routing_plot.py b/routing_plot.py
new file mode 100644
index 0000000000..6ce2061fed
--- /dev/null
+++ b/routing_plot.py
@@ -0,0 +1,223 @@
+#!/usr/bin/env python3
+
+import pandas as pd
+import matplotlib.pyplot as plt
+import seaborn as sns
+import numpy as np
+import os
+import sys
+
+# ==============================================================================
+# Configuration
+# ==============================================================================
+
+# --- Input: Path to the CSV file generated by run_routing.sh ---
+CSV_PATH = "lab4/routing_comparison/results_routing.csv"
+
+# --- Output: Directory to save the generated plot images ---
+PLOT_DIR = "lab4/routing_comparison/plots"
+
+# --- Plotting Style ---
+# Metrics to plot (Y-axis) vs. InjectionRate (X-axis)
+METRICS_TO_PLOT = {
+    "Throughput": "Throughput (pkts/node/cycle)",
+    "AvgTotalLatency": "Average Packet Latency (cycles)",
+}
+
+# Style cycles for lines and markers
+ROUTING_STYLES = {
+    0: {
+        "color": "blue",
+        "marker": "o",
+        "linestyle": "-",
+        "label": "Routing 0 (TABLE_)",
+    },
+    3: {
+        "color": "green",
+        "marker": "s",
+        "linestyle": "--",
+        "label": "Routing 3 (ADAPTIVE_)",
+    },
+    4: {
+        "color": "red",
+        "marker": "^",
+        "linestyle": ":",
+        "label": "Routing 4 (CAR_)",
+    },
+    5: {
+        "color": "purple",
+        "marker": "D",
+        "linestyle": "-.",
+        "label": "Routing 5 (UGAL_)",
+    }
+}
+
+# ==============================================================================
+# Script Logic
+# ==============================================================================
+
+
+def main():
+    """Main function to load data and generate plots."""
+    # --- 1. Pre-flight checks and setup ---
+    if not os.path.exists(CSV_PATH):
+        print(f"ERROR: CSV file not found at '{CSV_PATH}'", file=sys.stderr)
+        print("Please run ./run_routing.sh first.", file=sys.stderr)
+        sys.exit(1)
+
+    print(f"Reading data from: {CSV_PATH}")
+    try:
+        df = pd.read_csv(CSV_PATH)
+    except pd.errors.EmptyDataError:
+        print(f"ERROR: CSV file '{CSV_PATH}' is empty.", file=sys.stderr)
+        sys.exit(1)
+
+    os.makedirs(PLOT_DIR, exist_ok=True)
+    print(f"Plots will be saved to: {PLOT_DIR}")
+
+    # Style
+    sns.set_theme(style="whitegrid", palette="deep")
+
+    # --- 2. Get unique dimensions for plotting ---
+    topologies = df["Topology"].unique()
+    traffics = df["Traffic"].unique()
+
+    # --- 3. Generate a plot for each metric, topology, and traffic pattern ---
+    def safe_name(s: str) -> str:
+        return str(s).replace(" ", "_").replace("/", "_")
+
+    for metric_key, y_label in METRICS_TO_PLOT.items():
+        for topo in topologies:
+            for traffic in traffics:
+                # Filter data for the current scenario
+                subset = df[
+                    (df["Topology"] == topo) & (df["Traffic"] == traffic)
+                ]
+
+                if subset.empty:
+                    continue
+
+                print(
+                    f"Plotting [{metric_key}] for Topology='{topo}', Traffic='{traffic}'..."
+                )
+
+                # Create figure
+                fig, ax = plt.subplots(figsize=(12, 8))
+
+                # Plot a line for each routing algorithm
+                for routing_algo in sorted(subset["Routing"].unique()):
+                    routing_data = subset[
+                        subset["Routing"] == routing_algo
+                    ].sort_values("InjectionRate")
+                    style = ROUTING_STYLES.get(routing_algo, {})
+                    ax.plot(
+                        routing_data["InjectionRate"],
+                        routing_data[metric_key],
+                        label=style.get("label", f"Routing {routing_algo}"),
+                        color=style.get("color"),
+                        marker=style.get("marker"),
+                        linestyle=style.get("linestyle"),
+                    )
+                    # annotate peak for throughput metric
+                    if metric_key == "Throughput" and not routing_data.empty:
+                        idx = routing_data[metric_key].idxmax()
+                        x_pk = routing_data.loc[idx, "InjectionRate"]
+                        y_pk = routing_data.loc[idx, metric_key]
+                        ax.scatter(
+                            [x_pk], [y_pk], color=style.get("color"), zorder=5
+                        )
+                        ax.annotate(
+                            f"peak {y_pk:.3f}@{x_pk:.3f}",
+                            (x_pk, y_pk),
+                            textcoords="offset points",
+                            xytext=(6, 6),
+                            fontsize=8,
+                        )
+
+                # --- 4. Finalize and save the plot ---
+                ax.set_title(
+                    f"{metric_key} vs. Injection Rate\nTopology: {topo}, Traffic: {traffic}"
+                )
+                ax.set_xlabel("Injection Rate (pkts/node/cycle)")
+                ax.set_ylabel(y_label)
+                ax.grid(True, which="both", linestyle="--", linewidth=0.5)
+                ax.legend()
+
+                # Save the figure
+                plot_filename = f"{PLOT_DIR}/{metric_key}_{safe_name(topo)}_{safe_name(traffic)}.png"
+                fig.savefig(plot_filename, dpi=300, bbox_inches="tight")
+                plt.close(fig)
+
+                # Log-scale Y variant
+                yvals = subset[metric_key].replace(0, np.nan)
+                if np.isfinite(yvals).any():
+                    ymin = float(np.nanmin(yvals))
+                    fig, ax = plt.subplots(figsize=(12, 8))
+                    for routing_algo in sorted(subset["Routing"].unique()):
+                        routing_data = subset[
+                            subset["Routing"] == routing_algo
+                        ].sort_values("InjectionRate")
+                        style = ROUTING_STYLES.get(routing_algo, {})
+                        ax.plot(
+                            routing_data["InjectionRate"],
+                            routing_data[metric_key],
+                            label=style.get(
+                                "label", f"Routing {routing_algo}"
+                            ),
+                            color=style.get("color"),
+                            marker=style.get("marker"),
+                            linestyle=style.get("linestyle"),
+                        )
+                    ax.set_title(
+                        f"{metric_key} vs. Injection Rate (log-y)\nTopology: {topo}, Traffic: {traffic}"
+                    )
+                    ax.set_xlabel("Injection Rate (pkts/node/cycle)")
+                    ax.set_ylabel(y_label)
+                    ax.grid(True, which="both", linestyle="--", linewidth=0.5)
+                    ax.legend()
+                    ax.set_yscale("log")
+                    ax.set_ylim(bottom=max(1e-6, ymin))
+                    plot_filename_log = f"{PLOT_DIR}/{metric_key}_{safe_name(topo)}_{safe_name(traffic)}_logy.png"
+                    fig.savefig(
+                        plot_filename_log, dpi=300, bbox_inches="tight"
+                    )
+                    plt.close(fig)
+
+                # Additional useful figure: Latency vs Throughput
+                if set(["Throughput", "AvgTotalLatency"]).issubset(
+                    subset.columns
+                ):
+                    fig, ax = plt.subplots(figsize=(12, 8))
+                    for routing_algo in sorted(subset["Routing"].unique()):
+                        routing_data = subset[
+                            subset["Routing"] == routing_algo
+                        ].sort_values("InjectionRate")
+                        style = ROUTING_STYLES.get(routing_algo, {})
+                        ax.plot(
+                            routing_data["Throughput"],
+                            routing_data["AvgTotalLatency"],
+                            label=style.get(
+                                "label", f"Routing {routing_algo}"
+                            ),
+                            color=style.get("color"),
+                            marker=style.get("marker"),
+                            linestyle=style.get("linestyle"),
+                        )
+                    ax.set_title(
+                        f"Latency vs Throughput\nTopology: {topo}, Traffic: {traffic}"
+                    )
+                    ax.set_xlabel("Throughput (accepted pkts/node/cycle)")
+                    ax.set_ylabel("Average Packet Latency (cycles)")
+                    ax.grid(True, which="both", linestyle="--", linewidth=0.5)
+                    ax.legend()
+                    plot_filename_lvt = f"{PLOT_DIR}/LatencyVsThroughput_{safe_name(topo)}_{safe_name(traffic)}.png"
+                    fig.savefig(
+                        plot_filename_lvt, dpi=300, bbox_inches="tight"
+                    )
+                    plt.close(fig)
+
+    print("\nAll plots generated successfully.")
+
+
+if __name__ == "__main__":
+    main()
diff --git a/run_routing.sh b/run_routing.sh
new file mode 100644
index 0000000000..108e2039b5
--- /dev/null
+++ b/run_routing.sh
@@ -0,0 +1,190 @@
+#!/usr/bin/env bash
+# Parallel, topology-aware and routing-aware Garnet sweep runner
+# - Supports multiple topologies (each with its own extra args)
+# - Runs multiple synthetic traffic patterns
+# - Sweeps over multiple routing algorithms
+# - Parallelized with a job limit
+# - Hides gem5 stdout/stderr into per-run logs
+# - Appends results to a single CSV safely (flock)
+
+###############################################################################
+# Basic config
+###############################################################################
+GEM5_EXECUTABLE="./build/NULL/gem5.opt"
+GEM5_CONFIG="configs/example/garnet_synth_traffic.py"
+
+RESULTS_DIR="lab4/routing_comparison"
+TEMP_DIR="lab4/routing_comparison/tmp"
+OUTPUT_CSV="${RESULTS_DIR}/results_routing.csv"
+SIM_CYCLES=10000
+
+# TSV latency controls (Z-link timing):
+# Effective Z latency = link_latency * TSV_SLOWDOWN / TSV_SPEEDUP
+# Override via environment variables if desired.
+TSV_SLOWDOWN=${TSV_SLOWDOWN:-4}
+TSV_SPEEDUP=${TSV_SPEEDUP:-1}
+
+# Node counts (adjust as needed)
+NUM_CPUS=64
+NUM_DIRS=64
+
+# Concurrency (default: number of cores if available, else 4)
+JOBS=30
+
+# Synthetic patterns to sweep
+SYNTHETIC_PATTERNS=(uniform_random transpose)
+
+# Injection rates to sweep (0.02 -> 0.50 step 0.02)
+INJECTION_RATES=$(seq 0.05 0.05 0.50)
+
+# Routing algorithms to sweep
+ROUTING_ALGORITHMS=(0 3 4 5)
+
+# Topologies to sweep. Each entry is "TOPOLOGY|EXTRA_ARGS"
+TOPOLOGY_MATRIX=(
+  # 2D baseline (no TSV settings needed)
+  #"Mesh_XY|--mesh-rows=8"
+
+  # 3D topologies with per-topology TSV settings (edit here to tailor)
+  "Mesh3D_XYZ|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=4"
+  #"Torus3D|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=1"
+  "Sparse3D_Pillars|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=4"
+  #"Sparse3D_Pillars_torus|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=4"
+  "Cluster3D_Hub|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=4"
+  #"SW3D_Express|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=4"
+  "Hier3D_Chiplet|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=4"
+)
+
+###############################################################################
+# Safety checks
+###############################################################################
+scons build/NULL/gem5.opt -j $(nproc)
+set -u  # no undefined variables
+rm -rf "${RESULTS_DIR}" "${TEMP_DIR}"
+mkdir -p "${RESULTS_DIR}"
+mkdir -p "${TEMP_DIR}"
+
+if [[ ! -x "${GEM5_EXECUTABLE}" ]]; then
+  echo "ERROR: gem5 executable not found/executable at: ${GEM5_EXECUTABLE}"
+  exit 1
+fi
+if [[ ! -f "${GEM5_CONFIG}" ]]; then
+  echo "ERROR: gem5 config not found at: ${GEM5_CONFIG}"
+  exit 1
+fi
+
+###############################################################################
+# CSV header
+###############################################################################
+if [[ ! -f "${OUTPUT_CSV}" ]]; then
+  echo "Topology,Routing,Traffic,InjectionRate,Throughput,PacketsInjected,PacketsReceived,AvgTotalLatency,AvgHops" > "${OUTPUT_CSV}"
+fi
+
+LOCKFILE="${OUTPUT_CSV}.lock"
+touch "${LOCKFILE}"
+
+###############################################################################
+# Helper: throttle to $JOBS background tasks
+###############################################################################
+wait_for_slot() {
+  while [[ "$(jobs -rp | wc -l | tr -d ' ')" -ge "${JOBS}" ]]; do
+    sleep 0.2
+  done
+}
+
+###############################################################################
+# One simulation run
+# Args: <topology> <topo_args> <traffic> <rate> <routing_algo>
+###############################################################################
+run_one() {
+  local topo="$1"
+  local topo_args="$2"
+  local traffic="$3"
+  local rate="$4"
+  local routing_algo="$5"
+
+  local rate_tag
+  rate_tag="$(printf "%.3f" "${rate}" | sed 's/\\.//g')"
+
+  local OUTDIR="${TEMP_DIR}/m5out_${topo}_${traffic}_${rate_tag}_routing${routing_algo}"
+  mkdir -p "${OUTDIR}"
+
+  # Per-topology TSV overrides via environment:
+  #   export TSV_SLOWDOWN_Mesh3D_XYZ=6 TSV_SPEEDUP_Mesh3D_XYZ=1
+  #   export TSV_SLOWDOWN_Torus3D=4 TSV_SPEEDUP_Torus3D=2
+  # Any --tsv-* provided in topo_args override these defaults.
+  local topo_key
+  topo_key="$(echo "${topo}" | tr -c 'A-Za-z0-9' '_')"
+  local tsv_slow_topo tsv_fast_topo
+  eval "tsv_slow_topo=\${TSV_SLOWDOWN_${topo_key}:-${TSV_SLOWDOWN}}"
+  eval "tsv_fast_topo=\${TSV_SPEEDUP_${topo_key}:-${TSV_SPEEDUP}}"
+
+  "${GEM5_EXECUTABLE}" -d "${OUTDIR}" "${GEM5_CONFIG}" \
+    --network=garnet --num-cpus="${NUM_CPUS}" --num-dirs="${NUM_DIRS}" \
+    --topology="${topo}" \
+    --inj-vnet=0 --synthetic="${traffic}" --vcs-per-vnet=4 --escape-vc \
+    --sim-cycles="${SIM_CYCLES}" --injectionrate="${rate}"  --routing-algorithm=${routing_algo} \
+    --tsv-slowdown="${tsv_slow_topo}" --tsv-speedup="${tsv_fast_topo}" \
+    ${topo_args} \
+    > "${OUTDIR}/gem5.log" 2>&1
+  # --escape-vc
+  local STATS="${OUTDIR}/stats.txt"
+  if [[ -f "${STATS}" ]]; then
+    local line
+    line="$(
+      awk -v topology="${topo}" -v routing="${routing_algo}" -v traffic="${traffic}" -v rate="${rate}" \
+          -v cycles="${SIM_CYCLES}" -v nodes="${NUM_CPUS}" \
+          '
+            BEGIN { inj=0; rec=0; t_lat=0; hops=0; }
+            /system.ruby.network.packets_injected::total/ { inj=$2 }
+            /system.ruby.network.packets_received::total/ { rec=$2 }
+            /system.ruby.network.average_packet_latency/  { t_lat=$2 }
+            /system.ruby.network.average_hops/            { hops=$2 }
+            END {
+              throughput = (nodes>0 && cycles>0) ? rec / cycles / nodes : 0;
+              printf "%s,%d,%s,%.3f,%.6f,%.0f,%.0f,%.4f,%.4f\n",
+                     topology, routing, traffic, rate, throughput, inj, rec, t_lat, hops
+            }
+          ' \
+          "${STATS}"
+    )"
+
+    if command -v flock >/dev/null 2>&1; then
+      (
+        flock -x 200
+        echo "${line}" >> "${OUTPUT_CSV}"
+      ) 200>"${LOCKFILE}"
+    else
+      echo "${line}" >> "${OUTPUT_CSV}"
+    fi
+  else
+    echo "WARN: No stats.txt for ${topo}/${traffic} at rate ${rate} with routing ${routing_algo} (OUTDIR=${OUTDIR})"
+  fi
+}
+
+###############################################################################
+# Sweep loops (parallelized)
+###############################################################################
+echo "Starting gem5 simulations..."
+echo "Topologies: ${#TOPOLOGY_MATRIX[@]} | Routings: ${#ROUTING_ALGORITHMS[@]} | Patterns: ${#SYNTHETIC_PATTERNS[@]} | Rates: $(echo "${INJECTION_RATES}" | wc -w) | Jobs: ${JOBS}"
+
+for entry in "${TOPOLOGY_MATRIX[@]}"; do
+  IFS='|' read -r TOPO TOPO_ARGS <<< "${entry}"
+  for routing_algo in "${ROUTING_ALGORITHMS[@]}"; do
+    for traffic in "${SYNTHETIC_PATTERNS[@]}"; do
+      for rate in ${INJECTION_RATES}; do
+        printf "Queue: topo=%s, routing=%d, traffic=%s, rate=%.3f\n" "${TOPO}" "${routing_algo}" "${traffic}" "${rate}"
+        wait_for_slot
+        run_one "${TOPO}" "${TOPO_ARGS}" "${traffic}" "${rate}" "${routing_algo}" &
+      done
+    done
+  done
+done
+
+wait
+
+echo "------------------------------------------------------------------------"
+echo "All simulations complete. Results CSV: ${OUTPUT_CSV}"
+echo "Per-run logs under: ${TEMP_DIR}/m5out_*/* (see gem5.log for details)"
+echo "------------------------------------------------------------------------"
+/home/tommy/miniconda3/bin/python /home/tommy/gem5hjy/gem5/routing_plot.py
\ No newline at end of file
diff --git a/run_topo.sh b/run_topo.sh
new file mode 100644
index 0000000000..4e70254d73
--- /dev/null
+++ b/run_topo.sh
@@ -0,0 +1,193 @@
+#!/usr/bin/env bash
+# Parallel, topology-aware Garnet sweep runner
+# - Supports multiple topologies (each with its own extra args)
+# - Runs multiple synthetic traffic patterns
+# - Parallelized with a job limit
+# - Hides gem5 stdout/stderr into per-run logs
+# - Appends results to a single CSV safely (flock)
+
+###############################################################################
+# Basic config
+###############################################################################
+GEM5_EXECUTABLE="./build/NULL/gem5.opt"
+GEM5_CONFIG="configs/example/garnet_synth_traffic.py"
+
+RESULTS_DIR="lab4/sec2"
+TEMP_DIR="lab4/sec2/tmp"
+OUTPUT_CSV="${RESULTS_DIR}/results.csv"
+SIM_CYCLES=50000
+
+# TSV latency controls (Z-link timing):
+# Effective Z latency = link_latency * TSV_SLOWDOWN / TSV_SPEEDUP
+# Override via environment variables if desired.
+TSV_SLOWDOWN=${TSV_SLOWDOWN:-4}
+TSV_SPEEDUP=${TSV_SPEEDUP:-1}
+
+# Node counts (adjust as needed)
+NUM_CPUS=64
+NUM_DIRS=64
+
+# Concurrency (default: number of cores if available, else 4)
+JOBS="$(command -v nproc >/dev/null 2>&1 && nproc || echo 4)"
+
+# Synthetic patterns to sweep
+SYNTHETIC_PATTERNS=(uniform_random transpose neighbor) #tornado shuffle
+
+# Injection rates to sweep (0.02 -> 0.50 step 0.02)
+INJECTION_RATES=$(seq 0.02 0.02 0.50)
+
+# Topologies to sweep. Each entry is "TOPOLOGY|EXTRA_ARGS"
+# Edit/add as needed (you can include your custom ones here).
+TOPOLOGY_MATRIX=(
+  # 2D baseline (no TSV settings needed)
+  #"Mesh_XY|--mesh-rows=8"
+
+  # 3D topologies with per-topology TSV settings (edit here to tailor)
+  "Mesh3D_XYZ|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=4"
+  # "Torus3D|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=1"
+  #"Sparse3D_Pillars|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=4"
+  #"Sparse3D_Pillars_torus|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=4"
+  "Cluster3D_Hub|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=4"
+  #"Hier3D_ClusterHub|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=4"
+  # "SW3D_Express|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=4"
+  #"Hier3D_Chiplet|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=4"
+  # "PillarTorusExpress3D|--mesh-rows=4 --tsv-slowdown=4 --tsv-speedup=4"
+)
+
+###############################################################################
+# Safety checks
+###############################################################################
+set -u  # no undefined variables
+rm -rf "${RESULTS_DIR}" "${TEMP_DIR}"
+mkdir -p "${RESULTS_DIR}"
+mkdir -p "${TEMP_DIR}"
+
+if [[ ! -x "${GEM5_EXECUTABLE}" ]]; then
+  echo "ERROR: gem5 executable not found/executable at: ${GEM5_EXECUTABLE}"
+  exit 1
+fi
+if [[ ! -f "${GEM5_CONFIG}" ]]; then
+  echo "ERROR: gem5 config not found at: ${GEM5_CONFIG}"
+  exit 1
+fi
+
+###############################################################################
+# CSV header
+###############################################################################
+if [[ ! -f "${OUTPUT_CSV}" ]]; then
+  echo "Topology,Traffic,InjectionRate,Throughput,PacketsInjected,PacketsReceived,AvgTotalLatency,AvgHops" > "${OUTPUT_CSV}"
+fi
+
+LOCKFILE="${OUTPUT_CSV}.lock"
+touch "${LOCKFILE}"
+
+###############################################################################
+# Helper: throttle to $JOBS background tasks
+###############################################################################
+wait_for_slot() {
+  # Wait until the number of running jobs is below the limit
+  while [[ "$(jobs -rp | wc -l | tr -d ' ')" -ge "${JOBS}" ]]; do
+    sleep 0.2
+  done
+}
+
+###############################################################################
+# One simulation run
+# Args: <topology> <topo_args> <traffic> <rate>
+###############################################################################
+run_one() {
+  local topo="$1"
+  local topo_args="$2"
+  local traffic="$3"
+  local rate="$4"
+
+  # Create a tidy rate tag for folder names: e.g., 0.010 -> 0p010
+  local rate_tag
+  rate_tag="$(printf "%.3f" "${rate}" | sed 's/\\.//g')"
+
+  # Output directory per run
+  local OUTDIR="${TEMP_DIR}/m5out_${topo}_${traffic}_${rate_tag}"
+  mkdir -p "${OUTDIR}"
+
+  # Run gem5 (hide output, but keep per-run log)
+  # NOTE: using ${topo_args} unquoted on purpose to allow multiple args
+  # Per-topology TSV overrides via environment:
+  #   export TSV_SLOWDOWN_Mesh3D_XYZ=6 TSV_SPEEDUP_Mesh3D_XYZ=1
+  #   export TSV_SLOWDOWN_Torus3D=4 TSV_SPEEDUP_Torus3D=2
+  # Any --tsv-* provided in topo_args override these defaults.
+  local topo_key
+  topo_key="$(echo "${topo}" | tr -c 'A-Za-z0-9' '_')"
+  local tsv_slow_topo tsv_fast_topo
+  eval "tsv_slow_topo=\${TSV_SLOWDOWN_${topo_key}:-${TSV_SLOWDOWN}}"
+  eval "tsv_fast_topo=\${TSV_SPEEDUP_${topo_key}:-${TSV_SPEEDUP}}"
+  "${GEM5_EXECUTABLE}" -d "${OUTDIR}" "${GEM5_CONFIG}" \
+    --network=garnet --num-cpus="${NUM_CPUS}" --num-dirs="${NUM_DIRS}" \
+    --topology="${topo}" --vcs-per-vnet=4 \
+    --inj-vnet=0 --synthetic="${traffic}" \
+    --sim-cycles="${SIM_CYCLES}" --injectionrate="${rate}" --escape-vc --routing-algorithm=4 \
+    --tsv-slowdown="${tsv_slow_topo}" --tsv-speedup="${tsv_fast_topo}" \
+    ${topo_args} \
+    > "${OUTDIR}/gem5.log" 2>&1
+    #--escape-vc
+  #--link-latency=2 --router-latency=2
+  # Parse stats if present
+  local STATS="${OUTDIR}/stats.txt"
+  if [[ -f "${STATS}" ]]; then
+    # Use awk to extract metrics and compute throughput = rec / cycles / NUM_CPUS
+    local line
+    line="$(
+      awk -v topology="${topo}" -v traffic="${traffic}" -v rate="${rate}" \
+          -v cycles="${SIM_CYCLES}" -v nodes="${NUM_CPUS}" \
+          '\
+        BEGIN{ inj=0; rec=0; t_lat=0; hops=0; }\
+        /system\.ruby\.network\.packets_injected::total/ { inj=$2 }\
+        /system\.ruby\.network\.packets_received::total/ { rec=$2 }\
+        /system\.ruby\.network\.average_packet_latency/  { t_lat=$2 }\
+        /system\.ruby\.network\.average_hops/            { hops=$2 }\
+        END {\
+          throughput = (nodes>0 && cycles>0) ? rec / cycles / nodes : 0;\
+          printf "%s,%s,%.3f,%.6f,%.0f,%.0f,%.4f,%.4f\n",\
+                 topology, traffic, rate, throughput, inj, rec, t_lat, hops\
+        }' "${STATS}"
+    )"
+
+    # Append to CSV atomically
+    if command -v flock >/dev/null 2>&1; then
+      (
+        flock -x 200
+        echo "${line}" >> "${OUTPUT_CSV}"
+      ) 200>"${LOCKFILE}"
+    else
+      # Fallback (less robust without flock, but works)
+      echo "${line}" >> "${OUTPUT_CSV}"
+    fi
+  else
+    echo "WARN: No stats.txt for ${topo}/${traffic} at rate ${rate} (OUTDIR=${OUTDIR})"
+  fi
+}
+
+###############################################################################
+# Sweep loops (parallelized)
+###############################################################################
+echo "Starting gem5 simulations..."
+echo "Topologies: ${#TOPOLOGY_MATRIX[@]} | Patterns: ${#SYNTHETIC_PATTERNS[@]} | Rates: $(echo "${INJECTION_RATES}" | wc -w) | Jobs: ${JOBS}"
+
+for entry in "${TOPOLOGY_MATRIX[@]}"; do
+  IFS='|' read -r TOPO TOPO_ARGS <<< "${entry}"
+
+  for traffic in "${SYNTHETIC_PATTERNS[@]}"; do
+    for rate in ${INJECTION_RATES}; do
+      printf "Queue: topo=%s, traffic=%s, rate=%.3f\n" "${TOPO}" "${traffic}" "${rate}"
+      wait_for_slot
+      run_one "${TOPO}" "${TOPO_ARGS}" "${traffic}" "${rate}" &
+    done
+  done
+done
+
+# Wait for all jobs to finish
+wait
+
+echo "------------------------------------------------------------------------"
+echo "All simulations complete. Results CSV: ${OUTPUT_CSV}"
+echo "Per-run logs under: ${TEMP_DIR}/m5out_*/* (see gem5.log for details)"
+echo "------------------------------------------------------------------------"
diff --git a/src/mem/ruby/network/garnet/CommonTypes.hh b/src/mem/ruby/network/garnet/CommonTypes.hh
index 0bf6f3680d..0c58aa0880 100644
--- a/src/mem/ruby/network/garnet/CommonTypes.hh
+++ b/src/mem/ruby/network/garnet/CommonTypes.hh
@@ -44,14 +44,39 @@ namespace garnet

 // All common enums and typedefs go here

-enum flit_type {HEAD_, BODY_, TAIL_, HEAD_TAIL_,
-                CREDIT_, NUM_FLIT_TYPE_};
+// Extend flit types with control messages used by SPIN-style control flow.
+// PROBE_/MOVE_/CHECK_PROBE_/KILL_MOVE_ are no-ops in Garnet3.0 by default,
+// but enabled when the SPIN scheme is turned on via GarnetNetwork.
+enum flit_type {
+    HEAD_, BODY_, TAIL_, HEAD_TAIL_,
+    // SPIN control flits (optional):
+    PROBE_, MOVE_, CHECK_PROBE_, KILL_MOVE_,
+    CREDIT_,
+    NUM_FLIT_TYPE_
+};
 enum VC_state_type {IDLE_, VC_AB_, ACTIVE_, NUM_VC_STATE_TYPE_};
 enum VNET_type {CTRL_VNET_, DATA_VNET_, NULL_VNET_, NUM_VNET_TYPE_};
 enum flit_stage {I_, VA_, SA_, ST_, LT_, NUM_FLIT_STAGE_};
 enum link_type { EXT_IN_, EXT_OUT_, INT_, NUM_LINK_TYPES_ };
-enum RoutingAlgorithm { TABLE_ = 0, XY_ = 1, CUSTOM_ = 2,
-                        NUM_ROUTING_ALGORITHM_};
+enum RoutingAlgorithm {
+    TABLE_   = 0,
+    XY_      = 1,
+    CUSTOM_  = 2,
+    ADAPTIVE_ = 3,  // adaptive minimal, credit-aware (3D-ready)
+    CAR3D_    = 4,  // CAR-3D: EWMA + lookahead-inspired scoring
+    UGAL_     = 5,  // UGAL-L (local), single-segment non-minimal at source
+    NUM_ROUTING_ALGORITHM_
+};
+
+// SPIN: per-router move registry entry
+struct move_info {
+    int inport;                    // input port at this router
+    int vc;                        // input VC index at this router
+    int outport;                   // chosen outport for the move
+    int vc_at_downstream_router;   // input VC at next router (optional)
+    bool tail_moved;               // mark when tail is moved
+    int cur_move_count;            // number of flits moved so far
+};

 struct RouteInfo
 {
@@ -74,6 +99,18 @@ struct RouteInfo

 #define INFINITE_ 10000

+// Lightweight counter state for SPIN-style deadlock handling. These states are
+// used only when SPIN support is enabled (see GarnetNetwork::enable_spin_scheme).
+enum Counter_state {
+    s_off,
+    s_move,
+    s_frozen,
+    s_deadlock_detection,
+    s_forward_progress,
+    s_check_probe,
+    num_cntr_states
+};
+
 } // namespace garnet
 } // namespace ruby
 } // namespace gem5
diff --git a/src/mem/ruby/network/garnet/GarnetNetwork.cc b/src/mem/ruby/network/garnet/GarnetNetwork.cc
index 57922698e0..dfd75a2d38 100644
--- a/src/mem/ruby/network/garnet/GarnetNetwork.cc
+++ b/src/mem/ruby/network/garnet/GarnetNetwork.cc
@@ -76,6 +76,20 @@ GarnetNetwork::GarnetNetwork(const Params &p)
     if (m_enable_fault_model)
         fault_model = p.fault_model;

+    m_escape_vc_enabled = p.escape_vc_enabled;
+
+    // SPIN (optional)
+    m_spin_scheme_enabled = p.enable_spin_scheme;
+    m_spin_dd_thresh = p.dd_thresh;
+    m_spin_max_turn_cap = p.max_turn_capacity;
+
+    // Routing knobs
+    m_ewma_lambda = p.ewma_lambda;
+    m_car3d_alpha = p.car3d_alpha;
+    m_car3d_beta  = p.car3d_beta;
+    m_ugal_penalty = p.ugal_penalty;
+    m_ugal_tol     = p.ugal_tol;
+
     m_vnet_type.resize(m_virtual_networks);

     for (int i = 0 ; i < m_virtual_networks ; i++) {
@@ -150,6 +164,137 @@ GarnetNetwork::init()
             router->printFaultVector(std::cout);
         }
     }
+
+    // Escape VC: Build BFS tree
+    if (m_escape_vc_enabled) {
+        buildEscapeTree();
+    }
+}
+
+void GarnetNetwork::buildEscapeTree()
+{
+    const int N = m_routers.size();
+    if (N == 0) return;
+
+    // 1) Build adjacency from physical outports (ignore LOCAL)
+    std::vector<std::vector<std::pair<int,int>>> adj(N);
+    for (int u = 0; u < N; ++u) {
+        auto *R = m_routers[u];
+        const int nOut = R->get_num_outports();
+        for (int op = 0; op < nOut; ++op) {
+            auto dir = R->getOutportDirection(op);
+            if (dir == "Local") continue;
+            const int v = R->neighborIdByOutport(op);
+            if (v >= 0 && v < N) {
+                adj[u].push_back({op, v}); // (outport index, neighbor id)
+            }
+        }
+    }
+
+    // 2) BFS to build a *physical* spanning tree rooted at 0
+    std::vector<int> parent(N, -1);
+    std::vector<int> parentOutportAtChild(N, -1);
+    std::vector<std::vector<int>> children(N);
+    std::vector<char> seen(N, 0);
+    std::queue<int> q;
+    const int ROOT = 0;
+
+    seen[ROOT] = 1;
+    q.push(ROOT);
+    while (!q.empty()) {
+        int u = q.front(); q.pop();
+        for (auto [op, v] : adj[u]) {
+            if (seen[v]) continue;
+            // Tree edge u -> v
+            seen[v] = 1;
+            parent[v] = u;
+
+            // Outport at *child* to go UP to its parent:
+            // Note: This must be the *one-hop* port to reach the parent neighbor.
+            // We can find it by scanning child's outports for the back-edge.
+            int upOp = -1;
+            for (auto [op2, nb] : adj[v]) {
+                if (nb == u) { upOp = op2; break; }
+            }
+            assert(upOp != -1 && "Topology should be bidirectional");
+            parentOutportAtChild[v] = upOp;
+
+            children[u].push_back(v);
+            q.push(v);
+        }
+    }
+
+    // 3) Euler tour tin/tout for subtree membership
+    std::vector<int> tin(N, -1), tout(N, -1);
+    int timer = 0;
+    std::function<void(int)> dfs = [&](int u) {
+        tin[u] = timer++;
+        for (int v : children[u]) dfs(v);
+        tout[u] = timer;
+    };
+    dfs(ROOT);
+    m_tin_of_router = tin;
+    m_tout_of_router = tout;
+
+    // 3b) All-pairs unweighted hop distances on physical links (excluding Local)
+    m_min_hops.assign(N, std::vector<int>(N, INFINITE_));
+    for (int s = 0; s < N; ++s) {
+        std::queue<int> qq;
+        m_min_hops[s][s] = 0;
+        qq.push(s);
+        while (!qq.empty()) {
+            int x = qq.front(); qq.pop();
+            for (auto [op, y] : adj[x]) {
+                if (m_min_hops[s][y] == INFINITE_) {
+                    m_min_hops[s][y] = m_min_hops[s][x] + 1;
+                    qq.push(y);
+                }
+            }
+        }
+    }
+
+    // 4) Install into each RoutingUnit
+    for (int u = 0; u < N; ++u) {
+        auto &RU = m_routers[u]->getRoutingUnit();
+        // Fix: Set tree depth based on BFS distance, not uninitialized value
+        int depth = 0;
+        int curr = u;
+        while (parent[curr] != -1) {
+            depth++;
+            curr = parent[curr];
+        }
+        RU.setTreeDepth(depth);
+        RU.clearChildren();
+
+        // Parent outport at *this* router (UP direction)
+        if (u == ROOT) {
+            RU.setParentOutport(-1); // root has no parent
+        } else {
+            RU.setParentOutport(parentOutportAtChild[u]);
+        }
+
+        // Add children entries with (outport, tin, tout)
+        for (int v : children[u]) {
+            // outport at *u* to reach child v (DOWN direction)
+            int downOp = -1;
+            for (auto [op, nb] : adj[u]) {
+                if (nb == v) {
+                    downOp = op;
+                    break;
+                }
+            }
+            assert(downOp != -1);
+            RU.addChild(downOp, tin[v], tout[v]);
+        }
+        // Print the children (vector children info)
+        for (const auto& child : RU.getChildren()) {
+            DPRINTF(RubyNetwork, "Router %d has child outport idx %d dir %s (tin=%d, tout=%d)\n",
+                    u, child.outport, RU.getDirection(child.outport).c_str(), child.tin, child.tout);
+        }
+        // Print the parent
+        DPRINTF(RubyNetwork, "Router %d has parent outport %d dir %s\n",
+                u, RU.getParentOutport(), RU.getParentOutportDirection().c_str());
+    }
 }

 /*
@@ -528,6 +673,8 @@ GarnetNetwork::regStats()
             statistics::oneline)
         ;

+
+
     // Traffic distribution
     for (int source = 0; source < m_routers.size(); ++source) {
         m_data_traffic_distribution.push_back(
@@ -580,6 +727,8 @@ GarnetNetwork::collateStats()
     for (int i = 0; i < m_routers.size(); i++) {
         m_routers[i]->collateStats();
     }
+
+
 }

 void
diff --git a/src/mem/ruby/network/garnet/GarnetNetwork.hh b/src/mem/ruby/network/garnet/GarnetNetwork.hh
index db37628bea..cf5441bda7 100644
--- a/src/mem/ruby/network/garnet/GarnetNetwork.hh
+++ b/src/mem/ruby/network/garnet/GarnetNetwork.hh
@@ -84,7 +84,19 @@ class GarnetNetwork : public Network
     bool isFaultModelEnabled() const { return m_enable_fault_model; }
     FaultModel* fault_model;

-
+    bool isEscapeVcEnabled() const { return m_escape_vc_enabled; }
+
+    // SPIN (optional): global enable and threshold
+    bool isSpinSchemeEnabled() const { return m_spin_scheme_enabled; }
+    uint32_t getSpinDdThreshold() const { return m_spin_dd_thresh; }
+    uint32_t getSpinMaxTurnCapacity() const { return m_spin_max_turn_cap; }
+
+    // Routing knob getters
+    double getEwmaLambda() const { return m_ewma_lambda; }
+    double getCar3DAlpha() const { return m_car3d_alpha; }
+    double getCar3DBeta()  const { return m_car3d_beta; }
+    int    getUgalPenalty() const { return m_ugal_penalty; }
+    double getUgalTol()     const { return m_ugal_tol; }
     // Internal configuration
     bool isVNetOrdered(int vnet) const { return m_ordered[vnet]; }
     VNET_type
@@ -96,6 +108,7 @@ class GarnetNetwork : public Network
     int get_router_id(int ni, int vnet);


+
     // Methods used by Topology to setup the network
     void makeExtOutLink(SwitchID src, NodeID dest, BasicLink* link,
                      std::vector<NetDest>& routing_table_entry);
@@ -157,6 +170,18 @@ class GarnetNetwork : public Network
     void update_traffic_distribution(RouteInfo route);
     int getNextPacketID() { return m_next_packet_id++; }

+    int getTinIndex(int routerId) const { return m_tinIndex[routerId]; }
+    // Escape-tree helpers
+    int tinOf(int routerId) const { return m_tin_of_router[routerId]; }
+    int toutOf(int routerId) const { return m_tout_of_router[routerId]; }
+    // Topology distance helpers (unweighted hop count on physical links)
+    int minHopsBetween(int u, int v) const {
+        if (u < 0 || v < 0) return INFINITE_;
+        if (u >= (int)m_min_hops.size()) return INFINITE_;
+        if (v >= (int)m_min_hops[u].size()) return INFINITE_;
+        return m_min_hops[u][v];
+    }
+
   protected:
     // Configuration
     int m_num_rows;
@@ -167,6 +192,23 @@ class GarnetNetwork : public Network
     uint32_t m_buffers_per_data_vc;
     int m_routing_algorithm;
     bool m_enable_fault_model;
+    bool m_escape_vc_enabled;
+    std::vector<int> m_tinIndex;
+    std::vector<int> m_tin_of_router;
+    std::vector<int> m_tout_of_router;
+    std::vector<std::vector<int>> m_min_hops; // [src][dst] unweighted hops
+
+    // SPIN
+    bool m_spin_scheme_enabled{false};
+    uint32_t m_spin_dd_thresh{0};
+    uint32_t m_spin_max_turn_cap{100};
+
+    // Routing knobs
+    double m_ewma_lambda{0.2};
+    double m_car3d_alpha{1.0};
+    double m_car3d_beta{0.5};
+    int    m_ugal_penalty{2};
+    double m_ugal_tol{1.0};

     // Statistical variables
     statistics::Vector m_packets_received;
@@ -203,9 +245,12 @@ class GarnetNetwork : public Network
     std::vector<std::vector<statistics::Scalar *>> m_data_traffic_distribution;
     std::vector<std::vector<statistics::Scalar *>> m_ctrl_traffic_distribution;

+
+
   private:
     GarnetNetwork(const GarnetNetwork& obj);
     GarnetNetwork& operator=(const GarnetNetwork& obj);
+    void buildEscapeTree();

     std::vector<VNET_type > m_vnet_type;
     std::vector<Router *> m_routers;   // All Routers in Network
diff --git a/src/mem/ruby/network/garnet/GarnetNetwork.py b/src/mem/ruby/network/garnet/GarnetNetwork.py
index 128118309c..5676a9c3d5 100644
--- a/src/mem/ruby/network/garnet/GarnetNetwork.py
+++ b/src/mem/ruby/network/garnet/GarnetNetwork.py
@@ -45,13 +45,33 @@ class GarnetNetwork(RubyNetwork):
     vcs_per_vnet = Param.UInt32(4, "virtual channels per virtual network")
     buffers_per_data_vc = Param.UInt32(4, "buffers per data virtual channel")
     buffers_per_ctrl_vc = Param.UInt32(1, "buffers per ctrl virtual channel")
-    routing_algorithm = Param.Int(0, "0: Weight-based Table, 1: XY, 2: Custom")
+    routing_algorithm = Param.Int(
+        0,
+        "0: Weight-based Table, 1: XY, 2: Custom, 3: Adaptive minimal (credit-aware), 4: CAR-3D, 5: UGAL-L (local), 6: UGAL-Plus (congestion+EWMA)",
+    )
     enable_fault_model = Param.Bool(False, "enable network fault model")
     fault_model = Param.FaultModel(NULL, "network fault model")
+    escape_vc_enabled = Param.Bool(False, "enable escape virtual channel")
+
+    # SPIN scheme (optional): enable SPIN-style deadlock handling and threshold
+    enable_spin_scheme = Param.Bool(False, "enable SPIN synchronized-progress scheme")
+    dd_thresh = Param.UInt32(300, "SPIN deadlock-detection threshold (cycles)")
+    max_turn_capacity = Param.UInt32(100, "SPIN: max allowed turns for probe path")
     garnet_deadlock_threshold = Param.UInt32(
         50000, "network-level deadlock threshold"
     )

+    # Routing algorithm knobs (for 4=CAR3D, 5=UGAL-L, 6=UGAL-Plus)
+    # Shared EWMA smoothing (used by CAR3D/UGAL+)
+    ewma_lambda = Param.Float(0.2, "EWMA smoothing factor for outport credits (0..1)")
+
+    # CAR3D scoring weights
+    car3d_alpha = Param.Float(1.0, "CAR3D weight on instantaneous credits")
+    car3d_beta  = Param.Float(0.5, "CAR3D weight on EWMA credits")
+
+    # UGAL-L (local) knobs
+    ugal_penalty = Param.Int(2, "UGAL-L non-minimal detour penalty (in hop-equivalent)")
+    ugal_tol     = Param.Float(1.0, "UGAL-L tolerance multiplier (<1 to encourage non-min)")

 class GarnetNetworkInterface(ClockedObject):
     type = "GarnetNetworkInterface"
diff --git a/src/mem/ruby/network/garnet/InputUnit.cc b/src/mem/ruby/network/garnet/InputUnit.cc
index 179bb642b7..876a925f03 100644
--- a/src/mem/ruby/network/garnet/InputUnit.cc
+++ b/src/mem/ruby/network/garnet/InputUnit.cc
@@ -61,6 +61,11 @@ InputUnit::InputUnit(int id, PortDirection direction, Router *router)
     for (int i=0; i < m_num_vcs; i++) {
         virtualChannels.emplace_back();
     }
+
+    // SPIN (optional): init per-VC stall and frozen state
+    m_stall_count.assign(m_num_vcs, 0);
+    m_vc_frozen.assign(m_num_vcs, false);
+    m_fork_vector.assign(m_router->get_num_outports(), false);
 }

 /*
@@ -87,6 +92,139 @@ InputUnit::wakeup()
         int vc = t_flit->get_vc();
         t_flit->increment_hops(); // for stats

+        // SPIN control flits handling (subset)
+        if (m_router->spin_scheme_enabled()) {
+            flit_type ft = t_flit->get_type();
+            if (ft == PROBE_ || ft == MOVE_ || ft == CHECK_PROBE_ || ft == KILL_MOVE_) {
+                // Attach current router id as inport for forwarding semantics
+                t_flit->setInport(m_router->get_id());
+                if (ft == PROBE_) {
+                    if (t_flit->getSourceId() == m_router->get_id()) {
+                        if (verify_dependence_at_source(t_flit)) {
+                            m_router->set_loop_delay(Cycles(1));
+                            m_router->latch_path(t_flit);
+                            int move_id = m_router->send_move_msg(m_id, t_flit->getSourceVc());
+                            m_router->latch_source_id_buffer(m_router->get_id(), move_id);
+                            m_router->create_move_info_entry(m_id, t_flit->getSourceVc(), m_router->peek_path_top());
+                            m_router->set_counter(t_flit->getSourceInport(), t_flit->getSourceVc(), s_move, 0);
+                        } else {
+                            m_num_probes_dropped++;
+                        }
+                        delete t_flit;
+                        return;
+                    } else {
+                        // Drop if path turns exceed capacity
+                        if ((unsigned)t_flit->getNumTurns() > m_router->get_net_ptr()->getSpinMaxTurnCapacity()) {
+                            m_num_probes_dropped++;
+                            delete t_flit;
+                            return;
+                        }
+                        if (create_fork_vector(t_flit)) {
+                            m_router->fork_probes(t_flit, m_fork_vector);
+                        } else {
+                            m_num_probes_dropped++;
+                        }
+                        clear_fork_vector();
+                        delete t_flit;
+                        return;
+                    }
+                } else if (ft == MOVE_) {
+                    if (t_flit->getSourceId() == m_router->get_id()) {
+                        if (verify_dependence_at_source(t_flit)) {
+                            m_router->set_move_bit();
+                            m_router->set_counter(m_id, t_flit->getSourceVc(), s_forward_progress, 0);
+                        } else {
+                            m_router->send_kill_move(m_id);
+                            m_router->invalidate_path_buffer();
+                            m_router->invalidate_source_id_buffer();
+                            m_router->increment_counter_ptr();
+                            m_router->clear_move_registry();
+                            m_num_move_dropped++;
+                        }
+                        delete t_flit;
+                        return;
+                    } else {
+                        Counter_state cs = m_router->get_counter_state();
+                        if (!(cs == s_deadlock_detection || cs == s_off || cs == s_frozen)) {
+                            m_num_move_dropped++;
+                            delete t_flit; return;
+                        }
+                        if (cs == s_frozen && !m_router->partial_check_source_id_buffer(t_flit->getSourceId())) {
+                            m_num_move_dropped++;
+                            delete t_flit; return;
+                        }
+                        if (m_router->check_outport_entry_in_move_registry(t_flit->peekPathTop())) {
+                            m_num_move_dropped++;
+                            delete t_flit; return;
+                        }
+                        int mvc = find_move_vc(t_flit);
+                        if (mvc != -1) {
+                            m_router->set_move_bit();
+                            m_router->latch_source_id_buffer(t_flit->getSourceId(), t_flit->get_id());
+                            m_router->create_move_info_entry(m_id, mvc, t_flit->peekPathTop());
+                            m_router->set_counter(m_id, mvc, s_frozen, (unsigned)(1));
+                            m_router->forward_move(t_flit);
+                        } else {
+                            m_num_move_dropped++;
+                            delete t_flit;
+                        }
+                        return;
+                    }
+                } else if (ft == CHECK_PROBE_) {
+                    if (t_flit->getSourceId() == m_router->get_id()) {
+                        if (verify_dependence_at_source(t_flit)) {
+                            m_router->set_move_bit();
+                            m_router->set_counter(m_id, t_flit->getSourceVc(), s_forward_progress, 0);
+                        } else {
+                            m_router->send_kill_move(m_id);
+                            m_router->invalidate_path_buffer();
+                            m_router->invalidate_source_id_buffer();
+                            m_router->increment_counter_ptr();
+                            m_router->clear_move_registry();
+                            m_num_check_probe_dropped++;
+                        }
+                        delete t_flit;
+                        return;
+                    } else {
+                        assert(m_router->get_counter_state() == s_frozen);
+                        assert(m_router->partial_check_source_id_buffer(t_flit->getSourceId()));
+                        int mvc = find_move_vc(t_flit);
+                        if (mvc != -1) {
+                            m_router->set_move_bit();
+                            m_router->update_move_info_entry(m_id, mvc, t_flit->peekPathTop());
+                            m_router->set_counter(m_id, mvc, s_frozen, (unsigned)(1));
+                            m_router->forward_check_probe(t_flit);
+                        } else {
+                            m_num_check_probe_dropped++;
+                            delete t_flit;
+                        }
+                        return;
+                    }
+                } else if (ft == KILL_MOVE_) {
+                    if (t_flit->getSourceId() == m_router->get_id()) {
+                        delete t_flit; return;
+                    } else {
+                        if (m_router->partial_check_source_id_buffer(t_flit->getSourceId())) {
+                            t_flit->setMustSend(true);
+                            m_router->set_kill_move_processed_this_cycle();
+                            if (m_router->get_num_move_registry_entries() == 1) {
+                                m_router->reset_move_bit();
+                                m_router->increment_counter_ptr();
+                                m_router->invalidate_source_id_buffer();
+                                m_router->clear_move_registry();
+                            } else {
+                                m_router->invalidate_move_registry_entry(m_id, t_flit->peekPathTop());
+                            }
+                        } else {
+                            t_flit->setMustSend(false);
+                        }
+                        m_router->forward_kill_move(t_flit);
+                        return;
+                    }
+                }
+            }
+        }
+
         if ((t_flit->get_type() == HEAD_) ||
             (t_flit->get_type() == HEAD_TAIL_)) {

@@ -102,6 +240,14 @@ InputUnit::wakeup()
             // The output port field in the flit is updated after it wins SA
             grant_outport(vc, outport);

+            // SPIN: initialize deadlock detection counter on first HEAD
+            if (m_router->spin_scheme_enabled() &&
+                m_router->get_counter_state() == s_off &&
+                m_direction != "Local" &&
+                m_router->getOutportDirection(outport) != "Local") {
+                m_router->set_counter(m_id, vc, s_deadlock_detection, 0);
+            }
+
         } else {
             assert(virtualChannels[vc].get_state() == ACTIVE_);
         }
@@ -139,6 +285,60 @@ InputUnit::wakeup()
     }
 }

+// --- SPIN (optional) helpers ---
+void
+InputUnit::increment_stall(int vc)
+{
+    if (!m_router->get_net_ptr()->isSpinSchemeEnabled()) return;
+    // Only enable freezing when an escape path is available to guarantee
+    // forward progress in our simplified SPIN handling.
+    if (!m_router->get_net_ptr()->isEscapeVcEnabled()) return;
+    if (vc < 0 || vc >= (int)m_stall_count.size()) return;
+    if (m_vc_frozen[vc]) return; // already frozen
+    m_stall_count[vc]++;
+    const uint32_t thresh = m_router->get_net_ptr()->getSpinDdThreshold();
+    if (thresh > 0 && m_stall_count[vc] >= thresh) {
+        // Freeze this VC; SwitchAllocator will attempt an escape if enabled
+        m_vc_frozen[vc] = true;
+        DPRINTF(RubyNetwork, "Router %d InputUnit %s freezing VC %d after %u stalls\n",
+                m_router->get_id(), m_router->getPortDirectionName(get_direction()), vc, m_stall_count[vc]);
+    }
+}
+
+void
+InputUnit::reset_stall(int vc)
+{
+    if (vc < 0 || vc >= (int)m_stall_count.size()) return;
+    m_stall_count[vc] = 0;
+}
+
+void
+InputUnit::freeze_vc(int vc)
+{
+    if (!m_router->get_net_ptr()->isSpinSchemeEnabled()) return;
+    if (vc < 0 || vc >= (int)m_vc_frozen.size()) return;
+    m_vc_frozen[vc] = true;
+}
+
+void
+InputUnit::thaw_vc(int vc)
+{
+    if (vc < 0 || vc >= (int)m_vc_frozen.size()) return;
+    if (m_vc_frozen[vc]) {
+        DPRINTF(RubyNetwork, "Router %d InputUnit %s thaw VC %d\n",
+                m_router->get_id(), m_router->getPortDirectionName(get_direction()), vc);
+    }
+    m_vc_frozen[vc] = false;
+    reset_stall(vc);
+}
+
+bool
+InputUnit::is_vc_frozen(int vc) const
+{
+    if (vc < 0 || vc >= (int)m_vc_frozen.size()) return false;
+    return m_vc_frozen[vc];
+}
+
 // Send a credit back to upstream router for this VC.
 // Called by SwitchAllocator when the flit in this VC wins the Switch.
 void
@@ -183,6 +383,64 @@ InputUnit::resetStats()
     }
 }

+// --- SPIN helpers (subset) ---
+bool InputUnit::verify_dependence_at_source(flit *t_flit)
+{
+    // True if the VC’s currently latched outport matches the path’s expected next outport.
+    int vc = t_flit->getSourceVc();
+    if (vc < 0) return false;
+    int expected = -1;
+    // For PROBE, compare against path top; for MOVE/CHECK_PROBE, compare against router’s path buffer later
+    expected = t_flit->peekPathTop();
+    return (virtualChannels[vc].get_outport() == expected);
+}
+
+bool InputUnit::create_fork_vector(flit *t_flit)
+{
+    // For this inport’s vnet, mark all outports where a VC is ACTIVE and not Local.
+    int vnet = t_flit->get_vnet();
+    std::fill(m_fork_vector.begin(), m_fork_vector.end(), false);
+    int base = vnet * m_vc_per_vnet;
+    int end = base + m_vc_per_vnet;
+    bool any = false;
+    for (int i = base; i < end; ++i) {
+        if (virtualChannels[i].get_state() != ACTIVE_) return false;
+        int outp = virtualChannels[i].get_outport();
+        if (m_router->getOutportDirection(outp) == "Local") return false;
+        m_fork_vector[outp] = true;
+        any = true;
+    }
+    return any;
+}
+
+void InputUnit::clear_fork_vector()
+{
+    std::fill(m_fork_vector.begin(), m_fork_vector.end(), false);
+}
+
+int InputUnit::find_move_vc(flit *t_flit)
+{
+    // Choose a VC (in this vnet) whose outport matches the path top and contains head+tail
+    int vnet = t_flit->get_vnet();
+    int base = vnet * m_vc_per_vnet;
+    int end = base + m_vc_per_vnet;
+    int outp = t_flit->peekPathTop();
+    for (int i = base; i < end; ++i) {
+        if (virtualChannels[i].get_state() != ACTIVE_) return -1;
+        if (m_router->getOutportDirection(virtualChannels[i].get_outport()) == "Local") return -1;
+        if (virtualChannels[i].get_outport() == outp && virtualChannels[i].containsHeadAndTail())
+            return i;
+    }
+    return -1;
+}
+
+void InputUnit::reset_spin_stats()
+{
+    m_num_probes_dropped = 0;
+    m_num_move_dropped = 0;
+    m_num_check_probe_dropped = 0;
+}
+
 } // namespace garnet
 } // namespace ruby
 } // namespace gem5
diff --git a/src/mem/ruby/network/garnet/InputUnit.hh b/src/mem/ruby/network/garnet/InputUnit.hh
index 4c4baeb03e..24219de68d 100644
--- a/src/mem/ruby/network/garnet/InputUnit.hh
+++ b/src/mem/ruby/network/garnet/InputUnit.hh
@@ -63,6 +63,8 @@ class InputUnit : public Consumer

     inline PortDirection get_direction() { return m_direction; }

+    inline Router* getRouter() { return m_router; }
+
     inline void
     set_vc_idle(int vc, Tick curTime)
     {
@@ -105,6 +107,9 @@ class InputUnit : public Consumer
         return virtualChannels[invc].get_enqueue_time();
     }

+    // SPIN: expose VC state to router
+    inline VC_state_type get_vc_state(int vc) { return virtualChannels[vc].get_state(); }
+
     void increment_credit(int in_vc, bool free_signal, Tick curTime);

     inline flit*
@@ -131,6 +136,15 @@ class InputUnit : public Consumer
         return virtualChannels[invc].isReady(curTime);
     }

+    // --- SPIN (optional) ---
+    // Per-VC stall tracking and freeze/thaw helpers used by SPIN-style
+    // deadlock handling. These are no-ops unless enabled via network param.
+    void increment_stall(int vc);
+    void reset_stall(int vc);
+    void freeze_vc(int vc);
+    void thaw_vc(int vc);
+    bool is_vc_frozen(int vc) const;
+
     flitBuffer* getCreditQueue() { return &creditQueue; }

     inline void
@@ -157,6 +171,19 @@ class InputUnit : public Consumer

     void resetStats();

+    // SPIN stats accessors
+    unsigned get_num_probes_dropped() const { return m_num_probes_dropped; }
+    unsigned get_num_move_dropped() const { return m_num_move_dropped; }
+    unsigned get_num_check_probe_dropped() const { return m_num_check_probe_dropped; }
+    void reset_spin_stats();
+
+    // SPIN helpers used by router
+    bool create_fork_vector(flit *t_flit);
+    void clear_fork_vector();
+    int find_move_vc(flit *t_flit);
+    bool verify_dependence_at_source(flit *t_flit);
+    void un_freeze_vc(int vc) { thaw_vc(vc); }
+
   private:
     Router *m_router;
     int m_id;
@@ -172,6 +199,17 @@ class InputUnit : public Consumer
     // Statistical variables
     std::vector<double> m_num_buffer_writes;
     std::vector<double> m_num_buffer_reads;
+
+    // SPIN (optional): per-VC stall counters and frozen flags
+    std::vector<uint32_t> m_stall_count;
+    std::vector<bool> m_vc_frozen;
+
+    // SPIN: fork vector per outport
+    std::vector<bool> m_fork_vector;
+    // SPIN stats
+    unsigned m_num_probes_dropped = 0;
+    unsigned m_num_move_dropped = 0;
+    unsigned m_num_check_probe_dropped = 0;
 };

 } // namespace garnet
diff --git a/src/mem/ruby/network/garnet/NetworkInterface.cc b/src/mem/ruby/network/garnet/NetworkInterface.cc
index 31d625c4d5..5a22044375 100644
--- a/src/mem/ruby/network/garnet/NetworkInterface.cc
+++ b/src/mem/ruby/network/garnet/NetworkInterface.cc
@@ -290,6 +290,10 @@ NetworkInterface::wakeup()
             if (t_credit->is_free_signal()) {
                 outVcState[t_credit->get_vc()].setState(IDLE_,
                     curTick());
+                if (t_credit->get_vc() == 0) {
+                    DPRINTF(RubyNetwork, "Credit %s is free for escape VC 0\n",
+                            *t_credit);
+                }
             }
             delete t_credit;
         }
@@ -459,11 +463,17 @@ NetworkInterface::flitisizeMessage(MsgPtr msg_ptr, int vnet)
 int
 NetworkInterface::calculateVC(int vnet)
 {
-    for (int i = 0; i < m_vc_per_vnet; i++) {
+    for (int i = m_net_ptr->isEscapeVcEnabled() ? 1 : 0; i < m_vc_per_vnet; i++) {
         int delta = m_vc_allocator[vnet];
+
+        if (delta == 0 && m_net_ptr->isEscapeVcEnabled()){
+            delta = 1;
+            m_vc_allocator[vnet] = 1;
+        }
+
         m_vc_allocator[vnet]++;
         if (m_vc_allocator[vnet] == m_vc_per_vnet)
-            m_vc_allocator[vnet] = 0;
+            m_vc_allocator[vnet] = m_net_ptr->isEscapeVcEnabled() ? 1 : 0;

         if (outVcState[(vnet*m_vc_per_vnet) + delta].isInState(
                     IDLE_, curTick())) {
diff --git a/src/mem/ruby/network/garnet/NetworkLink.hh b/src/mem/ruby/network/garnet/NetworkLink.hh
index b60a513540..666b418363 100644
--- a/src/mem/ruby/network/garnet/NetworkLink.hh
+++ b/src/mem/ruby/network/garnet/NetworkLink.hh
@@ -61,6 +61,7 @@ class NetworkLink : public ClockedObject, public Consumer
     ~NetworkLink() = default;

     void setLinkConsumer(Consumer *consumer);
+    Consumer* getLinkConsumer() const { return link_consumer; }
     void setSourceQueue(flitBuffer *src_queue, ClockedObject *srcClockObject);
     virtual void setVcsPerVnet(uint32_t consumerVcs);
     void setType(link_type type) { m_type = type; }
diff --git a/src/mem/ruby/network/garnet/OutVcState.hh b/src/mem/ruby/network/garnet/OutVcState.hh
index 42ef9e9342..66c6d96751 100644
--- a/src/mem/ruby/network/garnet/OutVcState.hh
+++ b/src/mem/ruby/network/garnet/OutVcState.hh
@@ -52,6 +52,7 @@ class OutVcState
     inline bool has_credit()       { return (m_credit_count > 0); }
     void increment_credit();
     void decrement_credit();
+    int get_max_credit_count() const { return m_max_credit_count; }

     inline bool
     isInState(VC_state_type state, Tick request_time)
diff --git a/src/mem/ruby/network/garnet/OutputUnit.cc b/src/mem/ruby/network/garnet/OutputUnit.cc
index d5ad75327c..7d35c8e2aa 100644
--- a/src/mem/ruby/network/garnet/OutputUnit.cc
+++ b/src/mem/ruby/network/garnet/OutputUnit.cc
@@ -34,6 +34,7 @@
 #include "debug/RubyNetwork.hh"
 #include "mem/ruby/network/garnet/Credit.hh"
 #include "mem/ruby/network/garnet/CreditLink.hh"
+#include "mem/ruby/network/garnet/InputUnit.hh"
 #include "mem/ruby/network/garnet/Router.hh"
 #include "mem/ruby/network/garnet/flitBuffer.hh"

@@ -70,6 +71,14 @@ OutputUnit::decrement_credit(int out_vc)
     outVcState[out_vc].decrement_credit();
 }

+void
+OutputUnit::decrement_credit_by(int count, int out_vc)
+{
+    for (int i = 0; i < count; ++i) {
+        decrement_credit(out_vc);
+    }
+}
+
 void
 OutputUnit::increment_credit(int out_vc)
 {
@@ -99,6 +108,8 @@ OutputUnit::has_free_vc(int vnet)
 {
     int vc_base = vnet*m_vc_per_vnet;
     for (int vc = vc_base; vc < vc_base + m_vc_per_vnet; vc++) {
+        if (is_escape_vc_enabled() && (vc == vc_base + 0))
+            continue;
         if (is_vc_idle(vc, curTick()))
             return true;
     }
@@ -112,6 +123,8 @@ OutputUnit::select_free_vc(int vnet)
 {
     int vc_base = vnet*m_vc_per_vnet;
     for (int vc = vc_base; vc < vc_base + m_vc_per_vnet; vc++) {
+        if (is_escape_vc_enabled() && (vc == vc_base + 0))
+            continue;
         if (is_vc_idle(vc, curTick())) {
             outVcState[vc].setState(ACTIVE_, curTick());
             return vc;
@@ -121,6 +134,40 @@ OutputUnit::select_free_vc(int vnet)
     return -1;
 }

+bool
+OutputUnit::has_free_escape_vc(int vnet)
+{
+    int vc_base = vnet*m_vc_per_vnet;
+    return is_escape_vc_enabled() && is_vc_idle(vc_base, curTick());
+}
+
+int
+OutputUnit::set_escape_vc(int vnet)
+{
+    int vc = vnet*m_vc_per_vnet + 0;
+    // Require IDLE before allocating escape VC to a new packet.
+    // Do NOT reuse an ACTIVE escape VC for a different packet,
+    // even if it has credits; that breaks VC exclusivity and can
+    // lead to deadlock or head-of-line blocking.
+    if (is_vc_idle(vc, curTick())) {
+        outVcState[vc].setState(ACTIVE_, curTick());
+        DPRINTF(RubyNetwork, "OutputUnit at Router %d set escape VC %d to ACTIVE (was IDLE)\n",
+                m_router->get_id(), vc);
+        return vc;
+    } else {
+        DPRINTF(RubyNetwork, "OutputUnit at Router %d FAILED to set escape VC %d (not IDLE)\n",
+                m_router->get_id(), vc);
+        return -1;
+    }
+}
+
+
+bool
+OutputUnit::is_escape_vc_enabled() const
+{
+    return m_router->is_escape_vc_enabled();
+}
+
 /*
  * The wakeup function of the OutputUnit reads the credit signal from the
  * downstream router for the output VC (i.e., input VC at downstream router).
@@ -136,8 +183,14 @@ OutputUnit::wakeup()
         Credit *t_credit = (Credit*) m_credit_link->consumeLink();
         increment_credit(t_credit->get_vc());

-        if (t_credit->is_free_signal())
+        if (t_credit->is_free_signal()){
             set_vc_state(IDLE_, t_credit->get_vc(), curTick());
+            if (t_credit->get_vc() == 0) {
+                DPRINTF(RubyNetwork, "Credit %s is free for escape VC 0\n",
+                        *t_credit);
+            }
+        }
+

         delete t_credit;

@@ -157,6 +210,17 @@ void
 OutputUnit::set_out_link(NetworkLink *link)
 {
     m_out_link = link;
+    // Deduce the sink Router from the link's consumer (set on the dest side)
+    if (auto *cons = m_out_link->getLinkConsumer()) {
+        if (auto *sink_router = dynamic_cast<gem5::ruby::garnet::Router*>(cons)) {
+            m_dest_router_id = sink_router->get_id();
+        } else {
+            // Non-router consumer (e.g., NI for "Local")
+            m_dest_router_id = -1;
+        }
+    } else {
+        m_dest_router_id = -1;
+    }
 }

 void
@@ -170,6 +234,20 @@ OutputUnit::insert_flit(flit *t_flit)
 {
     outBuffer.insert(t_flit);
     m_out_link->scheduleEventAbsolute(m_router->clockEdge(Cycles(1)));
+
+    // Update CAR-3D EWMA with latest observed credits for this outport/vnet
+    // Compute vnet from assigned outvc
+    int vnet = t_flit->get_vc() / m_vc_per_vnet;
+    if (vnet >= 0 && vnet < (int)m_router->get_num_vnets()) {
+        const bool escape_en = is_escape_vc_enabled();
+        int base = vnet * m_vc_per_vnet;
+        int sum = 0;
+        for (int off = 0; off < m_vc_per_vnet; ++off) {
+            if (escape_en && off == 0) continue;
+            sum += get_credit_count(base + off);
+        }
+        m_router->getRoutingUnit().updateEwma(m_id, vnet, sum);
+    }
 }

 bool
diff --git a/src/mem/ruby/network/garnet/OutputUnit.hh b/src/mem/ruby/network/garnet/OutputUnit.hh
index b07035c43a..d1384d5c3b 100644
--- a/src/mem/ruby/network/garnet/OutputUnit.hh
+++ b/src/mem/ruby/network/garnet/OutputUnit.hh
@@ -65,10 +65,15 @@ class OutputUnit : public Consumer
     flitBuffer* getOutQueue();
     void print(std::ostream& out) const {};
     void decrement_credit(int out_vc);
+    void decrement_credit_by(int count, int out_vc);
     void increment_credit(int out_vc);
     bool has_credit(int out_vc);
     bool has_free_vc(int vnet);
     int select_free_vc(int vnet);
+    int set_escape_vc(int vnet);
+    bool has_free_escape_vc(int vnet);
+    inline NetworkLink* getOutLink() const { return m_out_link; }
+    int getDestRouterId() const { return m_dest_router_id; }

     inline PortDirection get_direction() { return m_direction; }

@@ -77,6 +82,7 @@ class OutputUnit : public Consumer
     {
         return outVcState[vc].get_credit_count();
     }
+    int get_max_credit_count(int vc) const { return outVcState[vc].get_max_credit_count(); }

     inline int
     get_outlink_id()
@@ -98,6 +104,8 @@ class OutputUnit : public Consumer

     void insert_flit(flit *t_flit);

+    bool is_escape_vc_enabled() const;
+
     inline int
     getVcsPerVnet()
     {
@@ -109,6 +117,7 @@ class OutputUnit : public Consumer

   private:
     Router *m_router;
+    int m_dest_router_id{-1};
     GEM5_CLASS_VAR_USED int m_id;
     PortDirection m_direction;
     int m_vc_per_vnet;
diff --git a/src/mem/ruby/network/garnet/Router.cc b/src/mem/ruby/network/garnet/Router.cc
index 5232b91897..a965cfe3ab 100644
--- a/src/mem/ruby/network/garnet/Router.cc
+++ b/src/mem/ruby/network/garnet/Router.cc
@@ -38,6 +38,7 @@
 #include "mem/ruby/network/garnet/InputUnit.hh"
 #include "mem/ruby/network/garnet/NetworkLink.hh"
 #include "mem/ruby/network/garnet/OutputUnit.hh"
+#include "mem/ruby/network/garnet/flitBuffer.hh"

 namespace gem5
 {
@@ -66,6 +67,9 @@ Router::init()

     switchAllocator.init();
     crossbarSwitch.init();
+
+    // SPIN: allocate state if enabled (safe to allocate always)
+    init_spin_scheme_ptr();
 }

 void
@@ -89,6 +93,14 @@ Router::wakeup()
         m_output_unit[outport]->wakeup();
     }

+    // Reset per-cycle flag for KILL_MOVE processing
+    reset_kill_move_processed_this_cycle();
+
+    // SPIN: counter timeout check to trigger probe/move/kill progression
+    if (spin_scheme_enabled()) {
+        check_counter_timeout();
+    }
+
     // Switch Allocation
     switchAllocator.wakeup();

@@ -147,7 +159,7 @@ Router::addOutPort(PortDirection outport_dirn,
 }

 PortDirection
-Router::getOutportDirection(int outport)
+Router::getOutportDirection(int outport) const
 {
     return m_output_unit[outport]->get_direction();
 }
@@ -187,6 +199,20 @@ Router::getPortDirectionName(PortDirection direction)
     return direction;
 }

+bool
+Router::is_escape_vc_enabled() const
+{
+    return m_network_ptr->isEscapeVcEnabled();
+}
+
+int
+Router::neighborIdByOutport(int outport) const
+{
+    auto dir = getOutportDirection(outport);
+    if (dir == "Local") return -1;
+    return m_output_unit[outport]->getDestRouterId();
+}
+
 void
 Router::regStats()
 {
@@ -216,6 +242,16 @@ Router::regStats()
         .name(name() + ".sw_output_arbiter_activity")
         .flags(statistics::nozero)
     ;
+
+    // UGAL stats
+    m_ugal_min_choices
+        .name(name() + ".ugal_min_choices")
+        .flags(statistics::nozero)
+    ;
+    m_ugal_nonmin_choices
+        .name(name() + ".ugal_nonmin_choices")
+        .flags(statistics::nozero)
+    ;
 }

 void
@@ -311,6 +347,366 @@ Router::functionalWrite(Packet *pkt)
     return num_functional_writes;
 }

+// ---------------- SPIN implementation (subset) ----------------
+void Router::init_spin_scheme_ptr()
+{
+    m_counter = std::make_unique<counter>();
+    m_counter->count = 0;
+    m_counter->thresh = Cycles(0);
+    m_counter->state = s_off;
+    m_counter->cptr = new pointer();
+
+    m_path_buffer = std::make_unique<path_buffer>();
+    while (!m_path_buffer->path.empty()) m_path_buffer->path.pop();
+    m_path_buffer->valid = false;
+
+    m_source_id_buffer = std::make_unique<source_id_buffer>();
+    m_source_id_buffer->valid = false;
+
+    probeQueue = std::make_unique<flitBuffer>();
+    moveQueue = std::make_unique<flitBuffer>();
+    kill_moveQueue = std::make_unique<flitBuffer>();
+    check_probeQueue = std::make_unique<flitBuffer>();
+}
+
+void Router::set_counter(unsigned input_port, unsigned vc, Counter_state state, unsigned thresh)
+{
+    m_counter->cptr->input_port = input_port;
+    unsigned vnet = vc / m_vc_per_vnet;
+    m_counter->cptr->vnet = vnet;
+    m_counter->cptr->vc = vc;
+    m_counter->state = state;
+    m_counter->count = 0;
+
+    switch (state) {
+        case s_move:
+        case s_check_probe:
+        case s_forward_progress:
+            m_counter->thresh = curCycle() + get_loop_delay();
+            break;
+        case s_frozen:
+            m_counter->thresh = curCycle() + Cycles(thresh);
+            break;
+        case s_deadlock_detection:
+            m_counter->thresh = curCycle() + Cycles(m_network_ptr->getSpinDdThreshold());
+            break;
+        default:
+            m_counter->thresh = Cycles(INFINITE_);
+            break;
+    }
+    if (state != s_off) {
+        assert((m_counter->thresh - curCycle()) > 0);
+        schedule_wakeup(Cycles(m_counter->thresh - curCycle()));
+    }
+}
+
+void Router::increment_counter_ptr()
+{
+    if (!m_counter) return;
+    unsigned cur_inp = m_counter->cptr->input_port;
+    unsigned cur_vc = m_counter->cptr->vc;
+
+    // Try remaining VCs on current inport
+    for (unsigned i = cur_vc + 1; i < m_num_vcs; ++i) {
+        int t_outport = getInputUnit(cur_inp)->get_outport(i);
+        if (getInputUnit(cur_inp)->get_vc_state(i) == ACTIVE_ && getOutportDirection(t_outport) != "Local") {
+            set_counter(cur_inp, i, s_deadlock_detection, 0);
+            return;
+        }
+    }
+    // Next inports
+    for (unsigned ip = cur_inp + 1; ip < m_input_unit.size(); ++ip) {
+        if (getInportDirection(ip) == "Local") continue;
+        for (unsigned j = 0; j < m_num_vcs; ++j) {
+            int t_outport = getInputUnit(ip)->get_outport(j);
+            if (getInputUnit(ip)->get_vc_state(j) == ACTIVE_ && getOutportDirection(t_outport) != "Local") {
+                set_counter(ip, j, s_deadlock_detection, 0);
+                return;
+            }
+        }
+    }
+    // Wrap around
+    for (unsigned ip = 0; ip <= cur_inp; ++ip) {
+        if (getInportDirection(ip) == "Local") continue;
+        for (unsigned j = 0; j < m_num_vcs; ++j) {
+            int t_outport = getInputUnit(ip)->get_outport(j);
+            if (getInputUnit(ip)->get_vc_state(j) == ACTIVE_ && getOutportDirection(t_outport) != "Local") {
+                set_counter(ip, j, s_deadlock_detection, 0);
+                return;
+            }
+        }
+    }
+    // No candidate
+    set_counter(cur_inp, cur_vc, s_off, 0);
+}
+
+void Router::check_counter_timeout()
+{
+    if (!m_counter || m_counter->state == s_off) return;
+    if (curCycle() < m_counter->thresh) return;
+    switch (m_counter->state) {
+        case s_deadlock_detection:
+            send_probe();
+            increment_counter_ptr();
+            break;
+        case s_move:
+            send_kill_move(m_counter->cptr->input_port);
+            invalidate_path_buffer();
+            invalidate_source_id_buffer();
+            clear_move_registry();
+            increment_counter_ptr();
+            break;
+        case s_frozen:
+            if (get_move_bit()) set_start_move();
+            break;
+        case s_forward_progress:
+            if (get_move_bit()) set_start_move();
+            break;
+        case s_check_probe:
+            send_kill_move(m_counter->cptr->input_port);
+            invalidate_path_buffer();
+            invalidate_source_id_buffer();
+            clear_move_registry();
+            increment_counter_ptr();
+            break;
+        default:
+            break;
+    }
+}
+
+void Router::latch_path(flit *f)
+{
+    m_path_buffer->path = f->get_path();
+    m_path_buffer->valid = true;
+}
+
+int Router::peek_path_top() const
+{
+    assert(m_path_buffer->valid);
+    return m_path_buffer->path.empty() ? -1 : m_path_buffer->path.front();
+}
+
+void Router::invalidate_path_buffer()
+{
+    m_path_buffer->valid = false;
+    while (!m_path_buffer->path.empty()) m_path_buffer->path.pop();
+}
+
+void Router::latch_source_id_buffer(int source_id, int move_id)
+{
+    m_source_id_buffer->source_id = source_id;
+    m_source_id_buffer->move_id = move_id;
+    m_source_id_buffer->valid = true;
+}
+
+void Router::invalidate_source_id_buffer()
+{
+    m_source_id_buffer->source_id = -1;
+    m_source_id_buffer->move_id = -1;
+    m_source_id_buffer->valid = false;
+}
+
+bool Router::check_source_id_buffer(int source_id, int move_id) const
+{
+    if (!m_source_id_buffer->valid) return false;
+    return (m_source_id_buffer->source_id == source_id && m_source_id_buffer->move_id == move_id);
+}
+
+bool Router::partial_check_source_id_buffer(int source_id) const
+{
+    if (!m_source_id_buffer->valid) return false;
+    return (m_source_id_buffer->source_id == source_id);
+}
+
+int Router::send_move_msg(int inport, int vc)
+{
+    int vnet = vc / m_vc_per_vnet;
+    // Build move flit from path buffer (output port sequence)
+    flit *move = new flit(get_id(), inport, vc, vnet, MOVE_,
+                          clockEdge(Cycles(1)) - Cycles(1), m_path_buffer->path);
+    // two-loop delay in ticks (approximate): use router latency cycles
+    Tick ld = clockEdge(get_loop_delay()) - clockEdge(Cycles(0));
+    move->addDelay(ld);
+    move->addDelay(ld);
+    // Subtract current router latency
+    move->subDelay(clockEdge(m_latency) - clockEdge(Cycles(0)));
+    moveQueue->insert(move);
+    if (m_latency > 1)
+        schedule_wakeup(Cycles(m_latency - Cycles(1)));
+    return move->get_id();
+}
+
+void Router::send_probe()
+{
+    // Build a probe for the currently pointed VC with dependency path comprising its outport
+    int inport = m_counter->cptr->input_port;
+    int vc = m_counter->cptr->vc;
+    int vnet = vc / m_vc_per_vnet;
+    std::queue<int> p;
+    p.push(getInputUnit(inport)->get_outport(vc));
+    flit *probe = new flit(get_id(), inport, vc, vnet, PROBE_,
+                           clockEdge(Cycles(1)) - Cycles(1), p);
+    Tick ld = clockEdge(get_loop_delay()) - clockEdge(Cycles(0));
+    probe->addDelay(ld);
+    probe->addDelay(ld);
+    probe->subDelay(clockEdge(m_latency) - clockEdge(Cycles(0)));
+    probeQueue->insert(probe);
+    if (m_latency > 1)
+        schedule_wakeup(Cycles(m_latency - Cycles(1)));
+}
+
+void Router::send_check_probe(int inport, int vc)
+{
+    int vnet = vc / m_vc_per_vnet;
+    // Build check-probe with current path buffer; outport set by constructor via path head
+    flit *cp = new flit(get_id(), inport, vc, vnet, CHECK_PROBE_, clockEdge(Cycles(1)) - Cycles(1), m_path_buffer->path);
+    Tick ld = clockEdge(get_loop_delay()) - clockEdge(Cycles(0));
+    cp->addDelay(ld);
+    cp->addDelay(ld);
+    cp->subDelay(clockEdge(m_latency) - clockEdge(Cycles(0)));
+    check_probeQueue->insert(cp);
+    if (m_latency > 1)
+        schedule_wakeup(Cycles(m_latency - Cycles(1)));
+}
+
+void Router::fork_probes(flit *t_flit, const std::vector<bool> &fork_vector)
+{
+    int vnet = t_flit->get_vnet();
+    for (int op = 0; op < (int)fork_vector.size(); ++op) {
+        if (!fork_vector[op]) continue;
+        std::queue<int> path = t_flit->get_path();
+        path.push(op);
+        flit *p = new flit(t_flit->getSourceId(), t_flit->getInport(), t_flit->getSourceVc(), vnet,
+                           PROBE_, clockEdge(Cycles(1)) - Cycles(1), path);
+        p->addDelay(t_flit->getDelay());
+    p->subDelay(clockEdge(m_latency) - clockEdge(Cycles(0)));
+        probeQueue->insert(p);
+    }
+}
+
+void Router::send_kill_move(int inport)
+{
+    flit *kill = new flit(get_id(), m_path_buffer->path, clockEdge(Cycles(1)) - Cycles(1), inport);
+    kill->setMustSend(true);
+    kill_moveQueue->insert(kill);
+    if (m_latency > 1) schedule_wakeup(Cycles(m_latency - Cycles(1)));
+}
+
+void Router::forward_kill_move(flit *kill_move)
+{
+    int outport = kill_move->getPathTop();
+    kill_move->set_outport(outport);
+    kill_move->set_time(clockEdge(Cycles(1)) - Cycles(1));
+    kill_moveQueue->insert(kill_move);
+    if (m_latency > 1) schedule_wakeup(Cycles(m_latency - Cycles(1)));
+}
+
+void Router::forward_move(flit *mv)
+{
+    mv->subDelay(clockEdge(m_latency) - clockEdge(Cycles(0)));
+    int outport = mv->getPathTop();
+    mv->set_outport(outport);
+    mv->set_time(clockEdge(Cycles(1)) - Cycles(1));
+    moveQueue->insert(mv);
+    if (m_latency > 1) schedule_wakeup(Cycles(m_latency - Cycles(1)));
+}
+
+void Router::forward_check_probe(flit *cp)
+{
+    cp->subDelay(clockEdge(m_latency) - clockEdge(Cycles(0)));
+    int outport = cp->getPathTop();
+    cp->set_outport(outport);
+    cp->set_time(clockEdge(Cycles(1)) - Cycles(1));
+    check_probeQueue->insert(cp);
+    if (m_latency > 1) schedule_wakeup(Cycles(m_latency - Cycles(1)));
+}
+
+void Router::create_move_info_entry(int inport, int vc, int outport)
+{
+    auto *mi = new move_info();
+    mi->inport = inport;
+    mi->vc = vc;
+    mi->outport = outport;
+    mi->vc_at_downstream_router = -1;
+    mi->tail_moved = false;
+    mi->cur_move_count = 0;
+    move_registry.push_back(mi);
+    getInputUnit(inport)->freeze_vc(vc);
+}
+
+void Router::update_move_info_entry(int inport, int vc, int outport)
+{
+    for (auto *mi : move_registry) {
+        if (mi->outport == outport) {
+            getInputUnit(inport)->thaw_vc(mi->vc);
+            mi->vc = vc;
+            getInputUnit(inport)->freeze_vc(vc);
+            return;
+        }
+    }
+}
+
+void Router::invalidate_move_registry_entry(int inport, int outport)
+{
+    for (auto it = move_registry.begin(); it != move_registry.end(); ++it) {
+        if ((*it)->outport == outport) {
+            getInputUnit(inport)->thaw_vc((*it)->vc);
+            delete *it;
+            move_registry.erase(it);
+            return;
+        }
+    }
+}
+
+bool Router::check_outport_entry_in_move_registry(int outport) const
+{
+    for (auto *mi : move_registry) if (mi->outport == outport) return true;
+    return false;
+}
+
+void Router::update_move_vc_at_downstream_router(int vc, int outport)
+{
+    for (auto *mi : move_registry) {
+        if (mi->outport == outport) { mi->vc_at_downstream_router = vc; return; }
+    }
+}
+
+void Router::invalidate_move_vcs()
+{
+    for (auto *mi : move_registry) {
+        mi->vc_at_downstream_router = -1;
+        mi->tail_moved = false;
+        mi->cur_move_count = 0;
+    }
+}
+
+void Router::clear_move_registry()
+{
+    for (auto *mi : move_registry) {
+        getInputUnit(mi->inport)->thaw_vc(mi->vc);
+        delete mi;
+    }
+    move_registry.clear();
+}
+
+void Router::move_complete()
+{
+    reset_start_move();
+    reset_move_bit();
+    if (get_counter_state() == s_forward_progress) {
+        assert(move_registry.size() == 1);
+        assert(move_registry[0]->inport == (int)m_counter->cptr->input_port);
+        assert(move_registry[0]->vc == (int)m_counter->cptr->vc);
+        // After a complete move along the cycle, initiate check-probe to pivot cross-overs
+        send_check_probe(m_counter->cptr->input_port, m_counter->cptr->vc);
+        set_counter(m_counter->cptr->input_port, m_counter->cptr->vc, s_check_probe, 0);
+        clear_move_registry();
+        create_move_info_entry(m_counter->cptr->input_port, m_counter->cptr->vc, peek_path_top());
+    } else {
+        invalidate_move_vcs();
+    }
+}
+
 } // namespace garnet
 } // namespace ruby
 } // namespace gem5
diff --git a/src/mem/ruby/network/garnet/Router.hh b/src/mem/ruby/network/garnet/Router.hh
index dbcdda9dbf..db14ecec0f 100644
--- a/src/mem/ruby/network/garnet/Router.hh
+++ b/src/mem/ruby/network/garnet/Router.hh
@@ -34,6 +34,7 @@

 #include <iostream>
 #include <memory>
+#include <queue>
 #include <vector>

 #include "mem/ruby/common/Consumer.hh"
@@ -62,6 +63,7 @@ class NetworkLink;
 class CreditLink;
 class InputUnit;
 class OutputUnit;
+class flitBuffer;

 class Router : public BasicRouter, public Consumer
 {
@@ -113,7 +115,7 @@ class Router : public BasicRouter, public Consumer

     int getBitWidth() { return m_bit_width; }

-    PortDirection getOutportDirection(int outport);
+    PortDirection getOutportDirection(int outport) const;
     PortDirection getInportDirection(int inport);

     int route_compute(RouteInfo route, int inport, PortDirection direction);
@@ -139,9 +141,88 @@ class Router : public BasicRouter, public Consumer
                                                       aggregate_fault_prob);
     }

+    bool is_escape_vc_enabled() const;
+    // For Escape Tree Routing
+    int escape_route_compute(RouteInfo route, int inport, PortDirection dir) {
+        return routingUnit.outportEscapeVC(route, inport, dir);
+    }
+
+    // Direction ↔ outport queries for setup
+    int outportIndexByDirection(PortDirection dir) const {
+        return routingUnit.outportIndex(dir);
+    }
+    RoutingUnit& getRoutingUnit() { return routingUnit; }
+    int neighborIdByOutport(int outport) const;
+
+    // UGAL decision stats (to verify engagement)
+    inline void incUGALMin() { m_ugal_min_choices++; }
+    inline void incUGALNonMin() { m_ugal_nonmin_choices++; }
+
     bool functionalRead(Packet *pkt, WriteMask &mask);
     uint32_t functionalWrite(Packet *);

+    // --- SPIN (optional) API ---
+    bool spin_scheme_enabled() const { return m_network_ptr->isSpinSchemeEnabled(); }
+    // Counter state and pointer
+    void init_spin_scheme_ptr();
+    void set_counter(unsigned input_port, unsigned vc, Counter_state state, unsigned thresh);
+    Counter_state get_counter_state() const { return m_counter ? m_counter->state : s_off; }
+    void increment_counter_ptr();
+    bool check_counter_ptr(unsigned inport, unsigned invc) {
+        return m_counter && m_counter->cptr && (m_counter->cptr->input_port == (int)inport) && (m_counter->cptr->vc == (int)invc);
+    }
+    void check_counter_timeout();
+    inline Cycles get_loop_delay() const { return loop_delay; }
+    inline void set_loop_delay(Cycles c) { loop_delay = c; }
+    int get_counter_inport() const { return m_counter ? m_counter->cptr->input_port : -1; }
+    int get_counter_vc() const { return m_counter ? m_counter->cptr->vc : -1; }
+
+    // SPIN queues (owned by Router)
+    flitBuffer* getProbeQueuePtr() { return probeQueue.get(); }
+    flitBuffer* getMoveQueuePtr() { return moveQueue.get(); }
+    flitBuffer* getKillMoveQueuePtr() { return kill_moveQueue.get(); }
+    flitBuffer* getCheckProbeQueuePtr() { return check_probeQueue.get(); }
+
+    // Move registry
+    void create_move_info_entry(int inport, int vc, int outport);
+    void update_move_info_entry(int inport, int vc, int outport);
+    void clear_move_registry();
+    const std::vector<move_info *>& get_move_registry() const { return move_registry; }
+    int get_num_move_registry_entries() const { return move_registry.size(); }
+    void invalidate_move_registry_entry(int inport, int outport);
+    bool check_outport_entry_in_move_registry(int outport) const;
+    void update_move_vc_at_downstream_router(int vc, int outport);
+    void invalidate_move_vcs();
+
+    // Path buffer and source id buffer
+    void latch_path(flit *f);
+    int peek_path_top() const;
+    void invalidate_path_buffer();
+    void latch_source_id_buffer(int source_id, int move_id);
+    void invalidate_source_id_buffer();
+    bool check_source_id_buffer(int source_id, int move_id) const;
+    bool partial_check_source_id_buffer(int source_id) const;
+    void set_move_bit() { m_move = true; }
+    void reset_move_bit() { m_move = false; }
+    bool get_move_bit() const { return m_move; }
+    void set_start_move() { start_move = true; }
+    void reset_start_move() { start_move = false; }
+    bool get_start_move() const { return start_move; }
+    inline void set_kill_move_processed_this_cycle() { kill_move_processed_this_cycle = true; }
+    inline void reset_kill_move_processed_this_cycle() { kill_move_processed_this_cycle = false; }
+    inline bool get_kill_move_processed_this_cycle() const { return kill_move_processed_this_cycle; }
+
+    // Control flit send/forward helpers
+    int send_move_msg(int inport, int vc);
+    void send_probe();
+    void send_check_probe(int inport, int vc);
+    void fork_probes(flit *t_flit, const std::vector<bool> &fork_vector);
+    void send_kill_move(int inport);
+    void forward_kill_move(flit *kill_move);
+    void forward_move(flit *move);
+    void forward_check_probe(flit *check_probe);
+    void move_complete();
+
   private:
     Cycles m_latency;
     uint32_t m_virtual_networks, m_vc_per_vnet, m_num_vcs;
@@ -163,6 +244,29 @@ class Router : public BasicRouter, public Consumer
     statistics::Scalar m_sw_output_arbiter_activity;

     statistics::Scalar m_crossbar_activity;
+
+    // UGAL statistics
+    statistics::Scalar m_ugal_min_choices;
+    statistics::Scalar m_ugal_nonmin_choices;
+
+    // --- SPIN state ---
+    struct pointer { unsigned input_port; unsigned vc; unsigned vnet; };
+    struct counter { pointer *cptr; unsigned count; Cycles thresh; Counter_state state; ~counter(){ delete cptr; } };
+    struct path_buffer { std::queue<int> path; bool valid = false; };
+    struct source_id_buffer { int source_id=-1; int move_id=-1; bool valid=false; };
+
+    std::unique_ptr<counter> m_counter;
+    std::unique_ptr<path_buffer> m_path_buffer;
+    std::unique_ptr<source_id_buffer> m_source_id_buffer;
+    bool m_move = false;
+    Cycles loop_delay = Cycles(0);
+    std::unique_ptr<flitBuffer> probeQueue;
+    std::unique_ptr<flitBuffer> moveQueue;
+    std::unique_ptr<flitBuffer> kill_moveQueue;
+    std::unique_ptr<flitBuffer> check_probeQueue;
+    bool kill_move_processed_this_cycle = false;
+    bool start_move = false;
+    std::vector<move_info*> move_registry;
 };

 } // namespace garnet
diff --git a/src/mem/ruby/network/garnet/RoutingUnit.cc b/src/mem/ruby/network/garnet/RoutingUnit.cc
index f6075fb651..a65ff90f6b 100644
--- a/src/mem/ruby/network/garnet/RoutingUnit.cc
+++ b/src/mem/ruby/network/garnet/RoutingUnit.cc
@@ -34,9 +34,12 @@
 #include "base/compiler.hh"
 #include "debug/RubyNetwork.hh"
 #include "mem/ruby/network/garnet/InputUnit.hh"
+#include "mem/ruby/network/garnet/OutputUnit.hh"
 #include "mem/ruby/network/garnet/Router.hh"
 #include "mem/ruby/slicc_interface/Message.hh"

+#include <tuple>
+
 namespace gem5
 {

@@ -193,6 +196,12 @@ RoutingUnit::outportCompute(RouteInfo route, int inport,
         // any custom algorithm
         case CUSTOM_: outport =
             outportComputeCustom(route, inport, inport_dirn); break;
+        case CAR3D_: outport =
+            outportComputeCar3D(route, inport, inport_dirn); break;
+        case ADAPTIVE_: outport =
+            outportComputeAdaptive(route, inport, inport_dirn); break;
+        case UGAL_: outport =
+            outportComputeUGAL(route, inport, inport_dirn); break;
         default: outport =
             lookupRoutingTable(route.vnet, route.net_dest); break;
     }
@@ -260,6 +269,56 @@ RoutingUnit::outportComputeXY(RouteInfo route,
     return m_outports_dirn2idx[outport_dirn];
 }

+int
+RoutingUnit::outportEscapeVC(RouteInfo route, int inport, PortDirection inport_dirn)
+{
+    // If the destination is attached here, use the LOCAL outport selected by table
+    if (route.dest_router == m_router->get_id()) {
+        return lookupRoutingTable(route.vnet, route.net_dest);
+    }
+
+    // We need to know whether dest is in one of my child subtrees.
+    // We encode subtree membership using Euler-tour tin/tout numbers that
+    // GarnetNetwork will install via addChild(outport, tin, tout).
+    const int dest = route.dest_router;
+    const int destTin =
+        m_router->get_net_ptr()->tinOf(dest);  // <-- get Euler time of dest
+    const int destTout =
+        m_router->get_net_ptr()->toutOf(dest);  // <-- get Euler time of dest
+
+    // Prefer DOWN if the destination is in some child's subtree.
+    // Use inclusive Euler-tour membership: [tin, tout)
+    // i.e., tin(child) <= tin(dest) < tout(child)
+    // This ensures we also match when dest is exactly the child.
+    // DOWN traffic can only go DOWN - this breaks UP->DOWN cycles
+    for (const auto &c : m_children) {
+        if (destTin >= c.tin && destTin < c.tout) {
+            DPRINTF(RubyNetwork, "RoutingUnit at Router %d "
+                                 "routing DOWN to child via outport %d\n",
+                    m_router->get_id(), c.outport);
+
+            return c.outport; // DOWN edge
+        }
+    }
+
+    // Otherwise, go UP toward the parent (if not root)
+    // UP traffic can continue UP or go DOWN, but with priority ordering
+    if (m_parentOutport != -1) {
+        DPRINTF(RubyNetwork, "RoutingUnit at Router %d "
+                                        "routing UP to parent via outport %d\n",
+                            m_router->get_id(), m_parentOutport);
+
+        return m_parentOutport;
+    }
+
+    // Root without a suitable child: fall back to table minimal (safe at root)
+    DPRINTF(RubyNetwork, "RoutingUnit at Router %d "
+                         "falling back to original routing (ROOT)\n",
+            m_router->get_id());
+
+    return lookupRoutingTable(route.vnet, route.net_dest);
+}
+
 // Template for implementing custom routing algorithm
 // using port directions. (Example adaptive)
 int
@@ -270,6 +329,341 @@ RoutingUnit::outportComputeCustom(RouteInfo route,
     panic("%s placeholder executed", __FUNCTION__);
 }

+int
+RoutingUnit::outportComputeAdaptive(RouteInfo route,
+                                 int inport,
+                                 PortDirection inport_dirn)
+{
+    // If destination NI is attached to this router, use LOCAL outport from table
+    if (route.dest_router == m_router->get_id()) {
+        return lookupRoutingTable(route.vnet, route.net_dest);
+    }
+
+    // 1) Collect minimal outport candidates using the routing table
+    const int vnet = route.vnet;
+    if (vnet < 0 || vnet >= (int)m_routing_table.size()) {
+        // Fallback: use table directly if vnet is out of range
+        return lookupRoutingTable(route.vnet, route.net_dest);
+    }
+
+    int min_weight = INFINITE_;
+    std::vector<int> candidates;
+    candidates.reserve(m_routing_table[vnet].size());
+
+    // Find minimum link weight among links that can reach destination
+    for (int link = 0; link < (int)m_routing_table[vnet].size(); link++) {
+        if (route.net_dest.intersectionIsNotEmpty(m_routing_table[vnet][link])) {
+            if (m_weight_table[link] <= min_weight)
+                min_weight = m_weight_table[link];
+        }
+    }
+    // Collect links whose weight == min_weight and that reach the destination
+    for (int link = 0; link < (int)m_routing_table[vnet].size(); link++) {
+        if (route.net_dest.intersectionIsNotEmpty(m_routing_table[vnet][link])) {
+            if (m_weight_table[link] == min_weight) {
+                candidates.push_back(link);
+            }
+        }
+    }
+
+    if (candidates.empty()) {
+        // No route exists; keep behavior consistent with TABLE_ mode
+        fatal("Fatal Error:: No Route exists from this Router.");
+        return -1;
+    }
+
+    // 2) If only one candidate, use it
+    if (candidates.size() == 1) {
+        return candidates.front();
+    }
+
+    // 3) Rank candidates by downstream free credits on this vnet (exclude escape VC)
+    auto creditScore = [&](int outport) -> int {
+        auto *outU = m_router->getOutputUnit(outport);
+        if (!outU) return -1; // prefer any valid over invalid
+        const int vcs_per_vnet = m_router->get_vc_per_vnet();
+        const bool escape_en   = m_router->is_escape_vc_enabled();
+        int base = vnet * vcs_per_vnet;
+        int sum = 0;
+        for (int off = 0; off < vcs_per_vnet; ++off) {
+            if (escape_en && off == 0) continue; // exclude escape
+            sum += outU->get_credit_count(base + off);
+        }
+        return sum;
+    };
+
+    int best = candidates.front();
+    int bestScore = creditScore(best);
+
+    for (size_t i = 1; i < candidates.size(); ++i) {
+        int c = candidates[i];
+        int s = creditScore(c);
+        if (s > bestScore) {
+            best = c; bestScore = s;
+        }
+    }
+
+    // 4) Tie-break using per-inport round-robin among top-scored candidates
+    // Collect equal-top candidates
+    std::vector<int> top;
+    top.reserve(candidates.size());
+    for (int c : candidates) {
+        if (creditScore(c) == bestScore) top.push_back(c);
+    }
+    if (top.size() == 1) return top.front();
+
+    unsigned &rr = m_rr_by_inport[inport];
+    int choice = top[rr % top.size()];
+    rr++;
+    return choice;
+}
+
+// UGAL-L (local), single-segment: at source router (Local inport), compare
+// minimal first hop vs a non-minimal first hop using local congestion and a
+// fixed distance penalty for the non-minimal option. Downstream routers use
+// minimal routing again (i.e., we only misroute the first hop of the packet).
+int
+RoutingUnit::outportComputeUGAL(RouteInfo route,
+                                int inport,
+                                PortDirection inport_dirn)
+{
+    // If destination NI is attached here, use LOCAL outport from table
+    if (route.dest_router == m_router->get_id()) {
+        return lookupRoutingTable(route.vnet, route.net_dest);
+    }
+
+    // Only the source router (Local inport) attempts UGAL; others use minimal
+    if (inport_dirn != "Local") {
+        return lookupRoutingTable(route.vnet, route.net_dest);
+    }
+
+    const int vnet = route.vnet;
+    if (vnet < 0 || vnet >= (int)m_routing_table.size()) {
+        return lookupRoutingTable(route.vnet, route.net_dest);
+    }
+
+    // 1) Build minimal candidate set via routing table min-weight filtering
+    int min_weight = INFINITE_;
+    std::vector<int> min_cands;
+    min_cands.reserve(m_routing_table[vnet].size());
+    for (int link = 0; link < (int)m_routing_table[vnet].size(); link++) {
+        if (route.net_dest.intersectionIsNotEmpty(m_routing_table[vnet][link])) {
+            if (m_weight_table[link] <= min_weight)
+                min_weight = m_weight_table[link];
+        }
+    }
+    for (int link = 0; link < (int)m_routing_table[vnet].size(); link++) {
+        if (route.net_dest.intersectionIsNotEmpty(m_routing_table[vnet][link]) &&
+            m_weight_table[link] == min_weight) {
+            min_cands.push_back(link);
+        }
+    }
+    if (min_cands.empty()) {
+        fatal("Fatal Error:: No Route exists from this Router.");
+        return -1;
+    }
+
+    auto creditSum = [&](int outport) -> int {
+        auto *outU = m_router->getOutputUnit(outport);
+        if (!outU) return -1;
+        const int vcs_per_vnet = m_router->get_vc_per_vnet();
+        const bool escape_en   = m_router->is_escape_vc_enabled();
+        const int base = vnet * vcs_per_vnet;
+        int sum = 0;
+        for (int off = 0; off < vcs_per_vnet; ++off) {
+            if (escape_en && off == 0) continue; // exclude escape VC
+            sum += outU->get_credit_count(base + off);
+        }
+        return sum;
+    };
+
+    auto occupancySum = [&](int outport) -> int {
+        auto *outU = m_router->getOutputUnit(outport);
+        if (!outU) return 1<<20; // very large
+        const int vcs_per_vnet = m_router->get_vc_per_vnet();
+        const bool escape_en   = m_router->is_escape_vc_enabled();
+        const int base = vnet * vcs_per_vnet;
+        int sum = 0;
+        for (int off = 0; off < vcs_per_vnet; ++off) {
+            if (escape_en && off == 0) continue;
+            const int vc_idx = base + off;
+            sum += (outU->get_max_credit_count(vc_idx) - outU->get_credit_count(vc_idx));
+        }
+        return sum;
+    };
+
+    // Choose best minimal outport by maximum free credits (min occupancy)
+    int best_min = min_cands.front();
+    int best_min_occ = occupancySum(best_min);
+    for (int c : min_cands) {
+        int occ = occupancySum(c);
+        if (occ < best_min_occ) { best_min_occ = occ; best_min = c; }
+    }
+
+    // 2) Build non-minimal candidate set = all physical outports except Local
+    //    and those in minimal candidate set. Pick the one with best credits.
+    std::vector<int> nonmin_cands;
+    const int nOut = m_router->get_num_outports();
+    nonmin_cands.reserve(nOut);
+    for (int op = 0; op < nOut; ++op) {
+        auto dir = m_router->getOutportDirection(op);
+        if (dir == "Local") continue;
+        if (std::find(min_cands.begin(), min_cands.end(), op) != min_cands.end())
+            continue;
+        nonmin_cands.push_back(op);
+    }
+
+    // If no non-minimal option exists (e.g., degree-1), choose minimal
+    if (nonmin_cands.empty()) {
+        return best_min;
+    }
+
+    int best_nonmin = nonmin_cands.front();
+    int best_nonmin_occ = occupancySum(best_nonmin);
+    for (int c : nonmin_cands) {
+        int occ = occupancySum(c);
+        if (occ < best_nonmin_occ) { best_nonmin_occ = occ; best_nonmin = c; }
+    }
+
+    // 3) UGAL-L decision: local estimate comparing minimal vs non-minimal.
+    //    cost = occupancy + distance_penalty. Use a fixed penalty for non-min.
+    //    This approximates extra hops for detour without topology assumptions.
+    const int distance_penalty_min    = 0; // measured from the next hop only
+    const int distance_penalty_nonmin = m_router->get_net_ptr()->getUgalPenalty();
+    const double tol = m_router->get_net_ptr()->getUgalTol();
+    const double cost_min    = (double)best_min_occ    + distance_penalty_min;
+    const double cost_nonmin = (double)best_nonmin_occ + distance_penalty_nonmin;
+
+    int choice = ((cost_nonmin * tol) < cost_min) ? best_nonmin : best_min;
+
+    // Tie-breaker: prefer minimal when costs equal
+    if (cost_nonmin == cost_min) choice = best_min;
+
+    // Update per-router stats to let us verify UGAL actually engages
+    if (choice == best_nonmin) m_router->incUGALNonMin();
+    else m_router->incUGALMin();
+
+    DPRINTF(RubyNetwork,
+            "UGAL @R%d inport %d dir %s: best_min=%d occ=%d, best_nonmin=%d occ=%d, choice=%d\n",
+            m_router->get_id(), inport, inport_dirn.c_str(), best_min, best_min_occ,
+            best_nonmin, best_nonmin_occ, choice);
+
+    return choice;
+}
+
+
+void RoutingUnit::ensureEwmaSized()
+{
+    const int num_outports = m_outports_idx2dirn.size();
+    const int num_vnets = m_router->get_num_vnets();
+    if ((int)m_outport_ewma.size() != num_outports) {
+        m_outport_ewma.resize(num_outports);
+    }
+    for (int op = 0; op < num_outports; ++op) {
+        if ((int)m_outport_ewma[op].size() != num_vnets) {
+            m_outport_ewma[op].assign(num_vnets, 0.0);
+        }
+    }
+}
+
+void RoutingUnit::updateEwma(int outport, int vnet, int observedCredits)
+{
+    ensureEwmaSized();
+    if (outport < 0 || outport >= (int)m_outport_ewma.size()) return;
+    if (vnet < 0 || vnet >= (int)m_outport_ewma[outport].size()) return;
+    double lambda = m_router->get_net_ptr()->getEwmaLambda();
+    if (lambda < 0.0) lambda = 0.0;
+    if (lambda > 1.0) lambda = 1.0;
+    double &ew = m_outport_ewma[outport][vnet];
+    ew = (1.0 - lambda) * ew + lambda * (double)observedCredits;
+}
+
+int
+RoutingUnit::outportComputeCar3D(RouteInfo route,
+                                 int inport,
+                                 PortDirection inport_dirn)
+{
+    // If destination NI is attached to this router, use LOCAL outport from table
+    if (route.dest_router == m_router->get_id()) {
+        return lookupRoutingTable(route.vnet, route.net_dest);
+    }
+
+    const int vnet = route.vnet;
+    if (vnet < 0 || vnet >= (int)m_routing_table.size()) {
+        return lookupRoutingTable(route.vnet, route.net_dest);
+    }
+
+    // Build minimal candidate set using table min-weight filtering
+    int min_weight = INFINITE_;
+    std::vector<int> candidates;
+    for (int link = 0; link < (int)m_routing_table[vnet].size(); link++) {
+        if (route.net_dest.intersectionIsNotEmpty(m_routing_table[vnet][link])) {
+            if (m_weight_table[link] <= min_weight)
+                min_weight = m_weight_table[link];
+        }
+    }
+    for (int link = 0; link < (int)m_routing_table[vnet].size(); link++) {
+        if (route.net_dest.intersectionIsNotEmpty(m_routing_table[vnet][link]) &&
+            m_weight_table[link] == min_weight) {
+            candidates.push_back(link);
+        }
+    }
+    if (candidates.empty()) {
+        fatal("Fatal Error:: No Route exists from this Router.");
+        return -1;
+    }
+    if (candidates.size() == 1) return candidates.front();
+
+    ensureEwmaSized();
+
+    auto localCredits = [&](int outport) -> int {
+        auto *outU = m_router->getOutputUnit(outport);
+        if (!outU) return -1;
+        const int vcs_per_vnet = m_router->get_vc_per_vnet();
+        const bool escape_en   = m_router->is_escape_vc_enabled();
+        int base = vnet * vcs_per_vnet;
+        int sum = 0;
+        for (int off = 0; off < vcs_per_vnet; ++off) {
+            if (escape_en && off == 0) continue; // exclude escape VC
+            sum += outU->get_credit_count(base + off);
+        }
+        return sum;
+    };
+
+    const double alpha = m_router->get_net_ptr()->getCar3DAlpha();
+    const double beta  = m_router->get_net_ptr()->getCar3DBeta();
+
+    // Compute best score
+    double bestScore = -1e18;
+    for (int c : candidates) {
+        double score = alpha * (double)localCredits(c) + beta * m_outport_ewma[c][vnet];
+        if (score > bestScore) bestScore = score;
+    }
+
+    // Keep only top-scored candidates (within epsilon)
+    const double eps = 1e-9;
+    std::vector<int> top;
+    for (int c : candidates) {
+        double score = alpha * (double)localCredits(c) + beta * m_outport_ewma[c][vnet];
+        if (score + eps >= bestScore) top.push_back(c);
+    }
+
+    // Stickiness: prefer last choice if it is still in top set
+    std::tuple<int,int,int> key{inport, vnet, route.dest_router};
+    auto it = m_lastChoice.find(key);
+    if (it != m_lastChoice.end()) {
+        int last = it->second;
+        for (int c : top) if (c == last) return last;
+    }
+
+    // Round-robin among top candidates
+    unsigned &rr = m_rr_by_inport[inport];
+    int choice = top[rr % top.size()];
+    rr++;
+    m_lastChoice[key] = choice;
+    return choice;
+}
+
 } // namespace garnet
 } // namespace ruby
 } // namespace gem5
diff --git a/src/mem/ruby/network/garnet/RoutingUnit.hh b/src/mem/ruby/network/garnet/RoutingUnit.hh
index e593afd080..64bb26b31d 100644
--- a/src/mem/ruby/network/garnet/RoutingUnit.hh
+++ b/src/mem/ruby/network/garnet/RoutingUnit.hh
@@ -37,6 +37,10 @@
 #include "mem/ruby/network/garnet/GarnetNetwork.hh"
 #include "mem/ruby/network/garnet/flit.hh"

+#include <map>
+#include <tuple>
+#include <vector>
+
 namespace gem5
 {

@@ -78,13 +82,62 @@ class RoutingUnit
                              int inport,
                              PortDirection inport_dirn);

+    // CAR-3D: EWMA + lookahead-inspired scoring
+    int outportComputeCar3D(RouteInfo route,
+                            int inport,
+                            PortDirection inport_dirn);
+
+    // Adaptive Routing Algorithm using Port Directions
+    int outportComputeAdaptive(RouteInfo route,
+                               int inport,
+                               PortDirection inport_dirn);
+
+    // UGAL-L (local): choose between minimal and one non-minimal first hop at source
+    int outportComputeUGAL(RouteInfo route,
+                           int inport,
+                           PortDirection inport_dirn);
+
+    // --- add near the top of class RoutingUnit public: ---
+    int outportEscapeVC(RouteInfo route, int inport, PortDirection inport_dirn);
+    int outportIndex(PortDirection dir) const {
+        auto it = m_outports_dirn2idx.find(dir);
+        return (it == m_outports_dirn2idx.end()) ? -1 : it->second;
+    }
+
+    // Install escape-tree info per router
+    void setTreeDepth(int depth) { m_treeDepth = depth; }
+    int getTreeDepth() const { return m_treeDepth; }
+    void setParentOutport(int outport) { m_parentOutport = outport; }
+
+    struct ChildInfo { int outport; int tin; int tout; };
+    void clearChildren() { m_children.clear(); }
+    void addChild(int outport, int tin, int tout) { m_children.push_back({outport,tin,tout}); }
+    std::vector<ChildInfo> getChildren() const { return m_children; }
     // Returns true if vnet is present in the vector
     // of vnets or if the vector supports all vnets.
     bool supportsVnet(int vnet, std::vector<int> sVnets);

+    // Get the direction for idx
+    PortDirection getDirection(int idx) const {
+        auto it = m_outports_idx2dirn.find(idx);
+        return (it == m_outports_idx2dirn.end()) ? "INVALID" : it->second;
+    }
+
+    int getParentOutport() const { return m_parentOutport; }
+    PortDirection getParentOutportDirection() const {
+        return getDirection(m_parentOutport);
+    }
+
+    // CAR-3D EWMA updater (called from OutputUnit on send)
+    void updateEwma(int outport, int vnet, int observedCredits);

   private:
     Router *m_router;
+    int m_treeDepth = -1;
+    int m_parentOutport = -1;
+    std::vector<ChildInfo> m_children;
+    // Tie-breaker state for adaptive selection (per inport)
+    std::map<int, unsigned> m_rr_by_inport;

     // Routing Table
     std::vector<std::vector<NetDest>> m_routing_table;
@@ -95,6 +148,13 @@ class RoutingUnit
     std::map<int, PortDirection> m_inports_idx2dirn;
     std::map<int, PortDirection> m_outports_idx2dirn;
     std::map<PortDirection, int> m_outports_dirn2idx;
+
+    // CAR-3D state
+    // Per-outport, per-vnet EWMA of observed free credits
+    std::vector<std::vector<double>> m_outport_ewma; // [outport][vnet]
+    std::map<std::tuple<int,int,int>, int> m_lastChoice; // key=(inport,vnet,dst)
+
+    void ensureEwmaSized();
 };

 } // namespace garnet
diff --git a/src/mem/ruby/network/garnet/SwitchAllocator.cc b/src/mem/ruby/network/garnet/SwitchAllocator.cc
index e31733d42e..cda7985df8 100644
--- a/src/mem/ruby/network/garnet/SwitchAllocator.cc
+++ b/src/mem/ruby/network/garnet/SwitchAllocator.cc
@@ -36,6 +36,7 @@
 #include "mem/ruby/network/garnet/InputUnit.hh"
 #include "mem/ruby/network/garnet/OutputUnit.hh"
 #include "mem/ruby/network/garnet/Router.hh"
+#include "mem/ruby/network/garnet/flitBuffer.hh"

 namespace gem5
 {
@@ -52,7 +53,6 @@ SwitchAllocator::SwitchAllocator(Router *router)
     m_router = router;
     m_num_vcs = m_router->get_num_vcs();
     m_vc_per_vnet = m_router->get_vc_per_vnet();
-
     m_input_arbiter_activity = 0;
     m_output_arbiter_activity = 0;
 }
@@ -66,16 +66,25 @@ SwitchAllocator::init()
     m_round_robin_invc.resize(m_num_inports);
     m_port_requests.resize(m_num_inports);
     m_vc_winners.resize(m_num_inports);
+    m_is_escape_req.resize(m_num_inports);

     for (int i = 0; i < m_num_inports; i++) {
         m_round_robin_invc[i] = 0;
         m_port_requests[i] = -1;
         m_vc_winners[i] = -1;
+        m_is_escape_req[i] = false;
     }

     for (int i = 0; i < m_num_outports; i++) {
         m_round_robin_inport[i] = 0;
     }
+
+    // SPIN queues and reservations
+    probeQueue = m_router->getProbeQueuePtr();
+    moveQueue = m_router->getMoveQueuePtr();
+    kill_moveQueue = m_router->getKillMoveQueuePtr();
+    check_probeQueue = m_router->getCheckProbeQueuePtr();
+    outport_reservations.assign(m_num_outports, false);
 }

 /*
@@ -90,11 +99,26 @@ SwitchAllocator::init()
 void
 SwitchAllocator::wakeup()
 {
-    arbitrate_inports(); // First stage of allocation
+    // SPIN send before normal arbitration
+    if (m_router->spin_scheme_enabled()) {
+        if (m_router->get_start_move()) effectuate_move();
+        send_check_probe();
+        send_move();
+        send_kill_move();
+        send_probes();
+    }
+
+    if (is_escape_vc_enabled()) {
+        arbitrate_inports_escape(); // First stage of allocation
+    } else {
+        arbitrate_inports(); // First stage of allocation
+    }
     arbitrate_outports(); // Second stage of allocation

     clear_request_vector();
     check_for_wakeup();
+
+    if (m_router->spin_scheme_enabled()) clear_reservations();
 }

 /*
@@ -107,6 +131,195 @@ SwitchAllocator::wakeup()
  * Places a request for the output port from this input VC.
  */

+void
+SwitchAllocator::arbitrate_inports()
+{
+    // Select a VC from each input in a round robin manner
+    // Independent arbiter at each input port
+    for (int inport = 0; inport < m_num_inports; inport++) {
+        int invc = m_round_robin_invc[inport];
+
+        for (int invc_iter = 0; invc_iter < m_num_vcs; invc_iter++) {
+            auto input_unit = m_router->getInputUnit(inport);
+
+            if (input_unit->need_stage(invc, SA_, curTick())) {
+                // This flit is in SA stage
+
+                // If SPIN is enabled and this VC is frozen, do not place a
+                // normal request in SA-I. Optionally, try to route via escape
+                // in the other SA variant when escape VC is enabled.
+                if (m_router->get_net_ptr()->isSpinSchemeEnabled() &&
+                    input_unit->is_vc_frozen(invc)) {
+                    // No request; keep the VC frozen. Try again next cycle.
+                    invc++;
+                    if (invc >= m_num_vcs) invc = 0;
+                    continue;
+                }
+
+                int outport = input_unit->get_outport(invc);
+                int outvc = input_unit->get_outvc(invc);
+
+                // check if the flit in this InputVC is allowed to be sent
+                // send_allowed conditions described in that function.
+                bool make_request =
+                    send_allowed(inport, invc, outport, outvc, is_escape_vc_enabled());
+
+                if (make_request) {
+                    m_input_arbiter_activity++;
+                    m_port_requests[inport] = outport;
+                    m_vc_winners[inport] = invc;
+                    // Reset stall counter on progress
+                    if (m_router->get_net_ptr()->isSpinSchemeEnabled())
+                        input_unit->reset_stall(invc);
+
+                    break; // got one vc winner for this port
+                } else if (m_router->get_net_ptr()->isSpinSchemeEnabled()) {
+                    input_unit->increment_stall(invc);
+                }
+            }
+
+            invc++;
+            if (invc >= m_num_vcs)
+                invc = 0;
+        }
+    }
+}
+
+void
+SwitchAllocator::arbitrate_inports_escape()
+{
+    // Independent arbiter at each input port
+    for (int inport = 0; inport < m_num_inports; inport++) {
+
+        auto *input_unit = m_router->getInputUnit(inport);
+        bool picked = false;
+
+        // ---------------------------------------------
+        // 1) Strong priority to ALL escape VCs (per vnet)
+        //    Scan invc = vnet*m_vc_per_vnet + 0 for all vnets
+        // ---------------------------------------------
+        if (is_escape_vc_enabled()) {
+            for (int invc = 0; invc < m_num_vcs; invc += m_vc_per_vnet) {
+                if (!input_unit->need_stage(invc, SA_, curTick()))
+                    continue;
+
+                const PortDirection inDir_esp = m_router->getInportDirection(inport);
+                flit *f_esp = input_unit->peekTopFlit(invc);
+                RouteInfo r_esp = f_esp->get_route();
+                int esc_outport = m_router->escape_route_compute(r_esp, inport, inDir_esp);
+
+                bool make_request = send_allowed(inport, invc, esc_outport, -1, true);
+
+                if (make_request) {
+                    m_input_arbiter_activity++;
+                    m_port_requests[inport] = esc_outport;
+                    m_vc_winners[inport]    = invc;   // escape VC for this vnet
+                    m_is_escape_req[inport] = true;
+                    picked = true;
+                    DPRINTF(RubyNetwork, "SwitchAllocator at Router %d granting escape invc %d at inport %d\n",
+                            m_router->get_id(), invc, inport);
+                    break;
+                } else {
+                    DPRINTF(RubyNetwork, "SwitchAllocator at Router %d denied escape invc %d at inport %d\n",
+                            m_router->get_id(), invc, inport);
+                }
+            }
+        }
+
+        if (picked) continue;
+
+        // ---------------------------------------------------
+        // 2) Otherwise, round-robin among non-escape VCs (offsets 1..)
+        //    Start from the saved pointer but skip VC indices that are escape
+        // ---------------------------------------------------
+        int start = m_round_robin_invc[inport];
+        if (start % m_vc_per_vnet == 0) start++; // skip escape index for that vnet
+
+        int invc = start;
+        for (int iter = 0; iter < m_num_vcs; iter++) {
+            if (invc >= m_num_vcs) invc = 0; // wrap
+            if (invc % m_vc_per_vnet == 0) { invc++; continue; } // skip escape
+
+            if (input_unit->need_stage(invc, SA_, curTick())) {
+                int outport = input_unit->get_outport(invc);
+                int outvc   = input_unit->get_outvc(invc);
+
+                // SPIN-aware: skip normal requests for frozen VCs
+                if (m_router->get_net_ptr()->isSpinSchemeEnabled() &&
+                    input_unit->is_vc_frozen(invc)) {
+                    invc++;
+                    continue;
+                }
+
+                bool make_request =
+                    send_allowed(inport, invc, outport, outvc, is_escape_vc_enabled());
+
+                // Fallback: if HEAD with no free outVC, try routing it via escape (VC0 at next hop)
+                if (!make_request && is_escape_vc_enabled() && outvc == -1) {
+                    const int vnet = get_vnet(invc);
+                    const PortDirection inDir = m_router->getInportDirection(inport);
+                    flit *f = input_unit->peekTopFlit(invc);
+                    RouteInfo r = f->get_route();
+                    int esc_outport = m_router->escape_route_compute(r, inport, inDir);
+
+                    auto *outU = m_router->getOutputUnit(esc_outport);
+                    const int esc_vc = vnet * m_vc_per_vnet + 0;
+
+                    DPRINTF(RubyNetwork, "SwitchAllocator at Router %d attempting escape "
+                            "outvc %d at outport %d for invc %d at inport %d\n",
+                            m_router->get_id(), esc_vc,
+                            m_router->getPortDirectionName(outU->get_direction()),
+                            invc,
+                            m_router->getPortDirectionName(input_unit->get_direction()));
+
+                    if (outU->is_vc_idle(esc_vc, curTick())) {
+                        outport = esc_outport;
+                        m_is_escape_req[inport] = true;
+                        m_port_requests[inport] = outport;
+                        m_vc_winners[inport]    = invc;
+                        DPRINTF(RubyNetwork, "SwitchAllocator at Router %d granted escape "
+                                "request for invc %d at inport %d\n",
+                                m_router->get_id(), invc,
+                                m_router->getPortDirectionName(input_unit->get_direction()));
+                        picked = true;
+                        break;
+                    } else {
+                        DPRINTF(RubyNetwork, "SwitchAllocator at Router %d failed escape "
+                                "request for invc %d at inport %d\n",
+                                m_router->get_id(), invc,
+                                m_router->getPortDirectionName(input_unit->get_direction()));
+                        DPRINTF(RubyNetwork,
+                                "ESC-STATE Router %d outport %s esc_vc=%d state=%s credits=%d\n",
+                                m_router->get_id(),
+                                m_router->getPortDirectionName(outU->get_direction()),
+                                esc_vc,
+                                outU->is_vc_idle(esc_vc, curTick()) ? "IDLE" : "ACTIVE",
+                                outU->get_credit_count(esc_vc));
+                    }
+                }
+
+                if (make_request) {
+                    m_input_arbiter_activity++;
+                    m_port_requests[inport] = outport;
+                    m_vc_winners[inport]    = invc;   // non-escape winner
+                    picked = true;
+                    if (m_router->get_net_ptr()->isSpinSchemeEnabled())
+                        input_unit->reset_stall(invc);
+                    break;
+                } else if (m_router->get_net_ptr()->isSpinSchemeEnabled()) {
+                    input_unit->increment_stall(invc);
+                }
+            }
+
+            invc++;
+        }
+    }
+}
+
+
+
+
+/*
 void
 SwitchAllocator::arbitrate_inports()
 {
@@ -127,7 +340,54 @@ SwitchAllocator::arbitrate_inports()
                 // check if the flit in this InputVC is allowed to be sent
                 // send_allowed conditions described in that function.
                 bool make_request =
-                    send_allowed(inport, invc, outport, outvc);
+                    send_allowed(inport, invc, outport, outvc, is_escape_vc_enabled());
+
+                if (!make_request && is_escape_vc_enabled() && invc != 0) {
+                    // If this is a HEAD and it failed because no free outVC,
+                    // try escape: compute escape outport and request it.
+                    if (outvc == -1) { // HEAD/HEAD_TAIL
+                        const int vnet = get_vnet(invc);
+                        const PortDirection inDir = m_router->getInportDirection(inport);
+                        flit *f = input_unit->peekTopFlit(invc); // non-destructive
+                        RouteInfo r = f->get_route();
+                        int esc_outport = m_router->escape_route_compute(r, inport, inDir);
+
+                        // Check that escape VC 0 on that outport is idle
+                        auto outU = m_router->getOutputUnit(esc_outport);
+                        const int esc_vc = vnet * m_vc_per_vnet + 0; // reserve 0
+
+                        DPRINTF(RubyNetwork, "SwitchAllocator at Router %d "
+                                             "attempting escape outvc %d at outport %d "
+                                             "for invc %d at inport %d\n",
+                                m_router->get_id(), esc_vc,
+                                m_router->getPortDirectionName(
+                                    outU->get_direction()),
+                                invc,
+                                m_router->getPortDirectionName(
+                                    input_unit->get_direction()));
+
+                        if (outU-> is_vc_idle(esc_vc, curTick())) {
+                            m_input_arbiter_activity++;
+                            outport = esc_outport;
+                            make_request = true;
+                            m_vc_winners[inport] = invc;
+                            m_port_requests[inport] = outport;
+                            m_is_escape_req[inport] = true;
+                            DPRINTF(RubyNetwork, "SwitchAllocator at Router %d "
+                                             "made escape request for invc %d at inport %d\n",
+                                m_router->get_id(), invc,
+                                m_router->getPortDirectionName(
+                                    input_unit->get_direction()));
+                            break;
+                        } else {
+                            DPRINTF(RubyNetwork, "SwitchAllocator at Router %d "
+                                             "failed escape request for invc %d at inport %d\n",
+                                m_router->get_id(), invc,
+                                m_router->getPortDirectionName(
+                                    input_unit->get_direction()));
+                        }
+                    }
+                }

                 if (make_request) {
                     m_input_arbiter_activity++;
@@ -144,6 +404,7 @@ SwitchAllocator::arbitrate_inports()
         }
     }
 }
+*/

 /*
  * SA-II (or SA-o) loops through all output ports,
@@ -166,104 +427,255 @@ SwitchAllocator::arbitrate_outports()
     // Again do round robin arbitration on these requests
     // Independent arbiter at each output port
     for (int outport = 0; outport < m_num_outports; outport++) {
-        int inport = m_round_robin_inport[outport];
+        // SPIN: skip this outport if reserved by control/move this cycle
+        if (m_router->spin_scheme_enabled() && outport_reservations[outport])
+            continue;
+        int start_inport = m_round_robin_inport[outport];
+
+        // First pass: give priority to escape requests targeting this outport
+        int chosen_inport = -1;
+        for (int iter = 0, inport = start_inport; iter < m_num_inports; iter++, inport++) {
+            if (inport >= m_num_inports) inport = 0;
+            if (m_port_requests[inport] == outport && m_is_escape_req[inport]) {
+                chosen_inport = inport;
+                break;
+            }
+        }

-        for (int inport_iter = 0; inport_iter < m_num_inports;
-                 inport_iter++) {
+        // Second pass: if no escape requester, pick any requester (round-robin)
+        if (chosen_inport == -1) {
+            for (int iter = 0, inport = start_inport; iter < m_num_inports; iter++, inport++) {
+                if (inport >= m_num_inports) inport = 0;
+                if (m_port_requests[inport] == outport) {
+                    chosen_inport = inport;
+                    break;
+                }
+            }
+        }

-            // inport has a request this cycle for outport
-            if (m_port_requests[inport] == outport) {
-                auto output_unit = m_router->getOutputUnit(outport);
-                auto input_unit = m_router->getInputUnit(inport);
+        if (chosen_inport == -1)
+            continue; // no requests for this outport

-                // grant this outport to this inport
-                int invc = m_vc_winners[inport];
+        // Process the chosen inport
+        int inport = chosen_inport;
+        auto output_unit = m_router->getOutputUnit(outport);
+        auto input_unit = m_router->getInputUnit(inport);

-                int outvc = input_unit->get_outvc(invc);
+        // grant this outport to this inport
+        int invc = m_vc_winners[inport];
+
+        int outvc = input_unit->get_outvc(invc);
+        if (outvc == -1) {
+            if (m_is_escape_req[inport] && is_escape_vc_enabled()) {
+                DPRINTF(RubyNetwork, "SwitchAllocator at Router %d granting escape VC %d at inport %d\n",
+                        m_router->get_id(), invc, inport);
+                outvc = m_router->getOutputUnit(outport)->set_escape_vc(get_vnet(invc));
                 if (outvc == -1) {
-                    // VC Allocation - select any free VC from outport
-                    outvc = vc_allocate(outport, inport, invc);
+                    // Critical: escape VC allocation failed, this should not happen
+                    // if send_allowed was correct, but handle gracefully
+                    DPRINTF(RubyNetwork, "CRITICAL: Router %d escape VC allocation FAILED for invc %d\n",
+                            m_router->get_id(), invc);
+                    // Skip this allocation and try next cycle
+                    m_port_requests[inport] = -1;
+                    continue;
                 }
-
-                // remove flit from Input VC
-                flit *t_flit = input_unit->getTopFlit(invc);
-
-                DPRINTF(RubyNetwork, "SwitchAllocator at Router %d "
-                                     "granted outvc %d at outport %d "
-                                     "to invc %d at inport %d to flit %s at "
-                                     "cycle: %lld\n",
-                        m_router->get_id(), outvc,
-                        m_router->getPortDirectionName(
-                            output_unit->get_direction()),
-                        invc,
-                        m_router->getPortDirectionName(
-                            input_unit->get_direction()),
-                            *t_flit,
-                        m_router->curCycle());
-
-
-                // Update outport field in the flit since this is
-                // used by CrossbarSwitch code to send it out of
-                // correct outport.
-                // Note: post route compute in InputUnit,
-                // outport is updated in VC, but not in flit
-                t_flit->set_outport(outport);
-
-                // set outvc (i.e., invc for next hop) in flit
-                // (This was updated in VC by vc_allocate, but not in flit)
-                t_flit->set_vc(outvc);
-
-                // decrement credit in outvc
-                output_unit->decrement_credit(outvc);
-
-                // flit ready for Switch Traversal
-                t_flit->advance_stage(ST_, curTick());
-                m_router->grant_switch(inport, t_flit);
-                m_output_arbiter_activity++;
-
-                if ((t_flit->get_type() == TAIL_) ||
-                    t_flit->get_type() == HEAD_TAIL_) {
-
-                    // This Input VC should now be empty
-                    assert(!(input_unit->isReady(invc, curTick())));
-
-                    // Free this VC
-                    input_unit->set_vc_idle(invc, curTick());
-
-                    // Send a credit back
-                    // along with the information that this VC is now idle
-                    input_unit->increment_credit(invc, true, curTick());
-                } else {
-                    // Send a credit back
-                    // but do not indicate that the VC is idle
-                    input_unit->increment_credit(invc, false, curTick());
+                input_unit->grant_outvc(invc, outvc);
+                // SPIN: allow frozen VC to make progress via escape
+                if (m_router->get_net_ptr()->isSpinSchemeEnabled()) {
+                    input_unit->thaw_vc(invc);
                 }
+            } else {
+                outvc = vc_allocate(outport, inport, invc); // normal path
+            }
+        }

-                // remove this request
-                m_port_requests[inport] = -1;
+        // remove flit from Input VC
+        flit *t_flit = input_unit->getTopFlit(invc);
+
+        DPRINTF(RubyNetwork, "SwitchAllocator at Router %d "
+                             "granted outvc %d at outport %d "
+                             "to invc %d at inport %d to flit %s at "
+                             "cycle: %lld\n",
+                m_router->get_id(), outvc,
+                m_router->getPortDirectionName(
+                    output_unit->get_direction()),
+                invc,
+                m_router->getPortDirectionName(
+                    input_unit->get_direction()),
+                    *t_flit,
+                m_router->curCycle());
+
+
+        // Update outport field in the flit since this is
+        // used by CrossbarSwitch code to send it out of
+        // correct outport.
+        // Note: post route compute in InputUnit,
+        // outport is updated in VC, but not in flit
+        t_flit->set_outport(outport);
+
+        // set outvc (i.e., invc for next hop) in flit
+        // (This was updated in VC by vc_allocate, but not in flit)
+        t_flit->set_vc(outvc);
+
+        // decrement credit in outvc
+        output_unit->decrement_credit(outvc);
+
+        // flit ready for Switch Traversal
+        t_flit->advance_stage(ST_, curTick());
+        m_router->grant_switch(inport, t_flit);
+        m_output_arbiter_activity++;
+
+        if ((t_flit->get_type() == TAIL_) ||
+            t_flit->get_type() == HEAD_TAIL_) {
+
+            // This Input VC should now be empty
+            assert(!(input_unit->isReady(invc, curTick())));
+
+            // Free this VC
+            input_unit->set_vc_idle(invc, curTick());
+
+            // Send a credit back
+            // along with the information that this VC is now idle
+            input_unit->increment_credit(invc, true, curTick());
+        } else {
+            // Send a credit back
+            // but do not indicate that the VC is idle
+            input_unit->increment_credit(invc, false, curTick());
+        }

-                // Update Round Robin pointer
-                m_round_robin_inport[outport] = inport + 1;
-                if (m_round_robin_inport[outport] >= m_num_inports)
-                    m_round_robin_inport[outport] = 0;
+        // remove this request
+        m_port_requests[inport] = -1;
+
+        // Update Round Robin pointer
+        m_round_robin_inport[outport] = inport + 1;
+        if (m_round_robin_inport[outport] >= m_num_inports)
+            m_round_robin_inport[outport] = 0;
+
+        // Update Round Robin pointer to the next VC
+        // We do it here to keep it fair.
+        // Only the VC which got switch traversal
+        // is updated.
+        m_round_robin_invc[inport] = invc + 1;
+        if (m_round_robin_invc[inport] >= m_num_vcs)
+            m_round_robin_invc[inport] = 0;
+    }
+}

-                // Update Round Robin pointer to the next VC
-                // We do it here to keep it fair.
-                // Only the VC which got switch traversal
-                // is updated.
-                m_round_robin_invc[inport] = invc + 1;
-                if (m_round_robin_invc[inport] >= m_num_vcs)
-                    m_round_robin_invc[inport] = 0;
+// ---------- SPIN sending primitives ----------
+void SwitchAllocator::send_probes()
+{
+    while (this->probeQueue && this->probeQueue->isReady(curTick())) {
+        flit *p = this->probeQueue->getTopFlit();
+        int outport = p->get_outport();
+        int inport = p->getInport();
+        if (outport < 0) { delete p; continue; }
+        if (outport_reservations[outport]) { delete p; continue; }
+        outport_reservations[outport] = true;
+        p->advance_stage(ST_, curTick());
+        m_router->grant_switch(inport, p);
+    }
+}

+void SwitchAllocator::send_move()
+{
+    while (this->moveQueue && this->moveQueue->isReady(curTick())) {
+        flit *mv = this->moveQueue->getTopFlit();
+        int outport = mv->get_outport();
+        int inport = mv->getInport();
+        if (outport < 0) { delete mv; continue; }
+        if (outport_reservations[outport]) { delete mv; continue; }
+        outport_reservations[outport] = true;
+        mv->advance_stage(ST_, curTick());
+        m_router->grant_switch(inport, mv);
+    }
+}

-                break; // got a input winner for this outport
+void SwitchAllocator::send_kill_move()
+{
+    while (this->kill_moveQueue && this->kill_moveQueue->isReady(curTick())) {
+        flit *km = this->kill_moveQueue->getTopFlit();
+        int outport = km->get_outport();
+        int inport = km->getInport();
+        if (km->getMustSend()) {
+            if (!outport_reservations[outport]) {
+                outport_reservations[outport] = true;
+                km->advance_stage(ST_, curTick());
+                m_router->grant_switch(inport, km);
+            } else {
+                delete km;
             }
+        } else {
+            if (outport_reservations[outport]) {
+                delete km;
+            } else {
+                outport_reservations[outport] = true;
+                km->advance_stage(ST_, curTick());
+                m_router->grant_switch(inport, km);
+            }
+        }
+    }
+}
+
+void SwitchAllocator::send_check_probe()
+{
+    while (this->check_probeQueue && this->check_probeQueue->isReady(curTick())) {
+        flit *cp = this->check_probeQueue->getTopFlit();
+        int outport = cp->get_outport();
+        int inport = cp->getInport();
+        if (outport < 0) { delete cp; continue; }
+        if (outport_reservations[outport]) { delete cp; continue; }
+        outport_reservations[outport] = true;
+        cp->advance_stage(ST_, curTick());
+        m_router->grant_switch(inport, cp);
+    }
+}

-            inport++;
-            if (inport >= m_num_inports)
-                inport = 0;
+void SwitchAllocator::effectuate_move()
+{
+    // Move flits for entries in move registry, bound by credits
+    const auto &registry = m_router->get_move_registry();
+    if (registry.empty()) return;
+    // For each entry, move the next flit if credits allow
+    for (auto *mi : registry) {
+        int outport = mi->outport;
+        if (outport_reservations[outport]) continue;
+        auto *input_unit = m_router->getInputUnit(mi->inport);
+        if (!input_unit->isReady(mi->vc, curTick())) continue;
+        // Assign/ensure outvc
+        int outvc = input_unit->get_outvc(mi->vc);
+        if (outvc == -1) {
+            outvc = m_router->getOutputUnit(outport)->select_free_vc(get_vnet(mi->vc));
+            if (outvc == -1) continue; // no VC
+            input_unit->grant_outvc(mi->vc, outvc);
+        }
+        auto *outU = m_router->getOutputUnit(outport);
+        if (!outU->has_credit(outvc)) continue;
+        // Remove flit and send
+        flit *t_flit = input_unit->getTopFlit(mi->vc);
+        t_flit->set_outport(outport);
+        t_flit->set_vc(outvc);
+        outU->decrement_credit(outvc);
+        t_flit->advance_stage(ST_, curTick());
+        outport_reservations[outport] = true;
+        m_router->grant_switch(mi->inport, t_flit);
+        if (t_flit->get_type() == TAIL_ || t_flit->get_type() == HEAD_TAIL_) {
+            // Free input VC and send free credit upstream
+            input_unit->set_vc_idle(mi->vc, curTick());
+            input_unit->increment_credit(mi->vc, true, curTick());
+            mi->tail_moved = true;
+        } else {
+            input_unit->increment_credit(mi->vc, false, curTick());
         }
     }
+    // Complete move if all moved tails
+    bool all_done = true;
+    for (auto *mi : registry) if (!mi->tail_moved) { all_done = false; break; }
+    if (all_done) m_router->move_complete();
+}
+
+void SwitchAllocator::clear_reservations()
+{
+    std::fill(outport_reservations.begin(), outport_reservations.end(), false);
 }

 /*
@@ -281,7 +693,7 @@ SwitchAllocator::arbitrate_outports()
  */

 bool
-SwitchAllocator::send_allowed(int inport, int invc, int outport, int outvc)
+SwitchAllocator::send_allowed(int inport, int invc, int outport, int outvc, bool is_escape_vc_enabled)
 {
     // Check if outvc needed
     // Check if credit needed (for multi-flit packet)
@@ -293,25 +705,45 @@ SwitchAllocator::send_allowed(int inport, int invc, int outport, int outvc)

     auto output_unit = m_router->getOutputUnit(outport);
     if (!has_outvc) {
+        DPRINTF(RubyNetwork, "Router %d SwitchAllocator::send_allowed for invc %d needs outvc for flit\n",
+                m_router->get_id(), invc);

         // needs outvc
         // this is only true for HEAD and HEAD_TAIL flits.
+        if (is_escape_vc_enabled && invc % m_vc_per_vnet == 0) {
+            // For escape VCs, require the escape VC be IDLE before use.
+            // Do NOT allow chaining onto an ACTIVE escape VC; that breaks
+            // exclusive ownership and can cause deadlock/HOL blocking.
+            if (output_unit->has_free_escape_vc(vnet)) {
+                has_outvc = true;
+                has_credit = true; // VC will have at least one buffer
+            }
+        } else {
+            if (output_unit->has_free_vc(vnet)) {

-        if (output_unit->has_free_vc(vnet)) {
-
-            has_outvc = true;
+                has_outvc = true;

-            // each VC has at least one buffer,
-            // so no need for additional credit check
-            has_credit = true;
+                // each VC has at least one buffer,
+                // so no need for additional credit check
+                has_credit = true;
+            }
         }
+
     } else {
         has_credit = output_unit->has_credit(outvc);
     }

     // cannot send if no outvc or no credit.
-    if (!has_outvc || !has_credit)
+    if (!has_outvc || !has_credit) {
+        // For escape VCs, add more detailed logging
+        if (is_escape_vc_enabled && invc % m_vc_per_vnet == 0) {
+            int esc_vc = vnet * m_vc_per_vnet + 0;
+            DPRINTF(RubyNetwork, "Router %d ESCAPE VC BLOCKED: invc=%d outport=%d has_outvc=%s has_credit=%s esc_vc_credits=%d\n",
+                    m_router->get_id(), invc, outport, has_outvc ? "yes" : "no", has_credit ? "yes" : "no",
+                    output_unit->get_credit_count(esc_vc));
+        }
         return false;
+    }


     // protocol ordering check
@@ -342,8 +774,14 @@ int
 SwitchAllocator::vc_allocate(int outport, int inport, int invc)
 {
     // Select a free VC from the output port
-    int outvc =
-        m_router->getOutputUnit(outport)->select_free_vc(get_vnet(invc));
+
+    int outvc = -1;
+    if (is_escape_vc_enabled() && invc % m_vc_per_vnet == 0){
+        DPRINTF(RubyNetwork, "Escape VC allocation should not be performed");
+        assert(false);
+    } else {
+        outvc = m_router->getOutputUnit(outport)->select_free_vc(get_vnet(invc));
+    }

     // has to get a valid VC since it checked before performing SA
     assert(outvc != -1);
@@ -380,6 +818,11 @@ SwitchAllocator::get_vnet(int invc)
     return vnet;
 }

+bool
+SwitchAllocator::is_escape_vc_enabled() const
+{
+    return m_router->is_escape_vc_enabled();
+}

 // Clear the request vector within the allocator at end of SA-II.
 // Was populated by SA-I.
@@ -387,6 +830,7 @@ void
 SwitchAllocator::clear_request_vector()
 {
     std::fill(m_port_requests.begin(), m_port_requests.end(), -1);
+    std::fill(m_is_escape_req.begin(), m_is_escape_req.end(), false);
 }

 void
diff --git a/src/mem/ruby/network/garnet/SwitchAllocator.hh b/src/mem/ruby/network/garnet/SwitchAllocator.hh
index 1072e0ad12..dc72f9772c 100644
--- a/src/mem/ruby/network/garnet/SwitchAllocator.hh
+++ b/src/mem/ruby/network/garnet/SwitchAllocator.hh
@@ -50,6 +50,7 @@ namespace garnet
 class Router;
 class InputUnit;
 class OutputUnit;
+class flitBuffer;

 class SwitchAllocator : public Consumer
 {
@@ -63,9 +64,9 @@ class SwitchAllocator : public Consumer
     void print(std::ostream& out) const {};
     void arbitrate_inports();
     void arbitrate_outports();
-    bool send_allowed(int inport, int invc, int outport, int outvc);
+    bool send_allowed(int inport, int invc, int outport, int outvc, bool is_escape_vc_enabled);
     int vc_allocate(int outport, int inport, int invc);
-
+    void arbitrate_inports_escape();
     inline double
     get_input_arbiter_activity()
     {
@@ -77,8 +78,18 @@ class SwitchAllocator : public Consumer
         return m_output_arbiter_activity;
     }

+    bool is_escape_vc_enabled() const;
+
     void resetStats();

+    // SPIN helpers
+    void send_probes();
+    void send_move();
+    void send_kill_move();
+    void send_check_probe();
+    void effectuate_move();
+    void clear_reservations();
+
   private:
     int m_num_inports, m_num_outports;
     int m_num_vcs, m_vc_per_vnet;
@@ -86,10 +97,18 @@ class SwitchAllocator : public Consumer
     double m_input_arbiter_activity, m_output_arbiter_activity;

     Router *m_router;
+    std::vector<bool> m_is_escape_req;
     std::vector<int> m_round_robin_invc;
     std::vector<int> m_round_robin_inport;
     std::vector<int> m_port_requests;
     std::vector<int> m_vc_winners;
+
+    // SPIN state (allocator-local)
+    flitBuffer *probeQueue{nullptr};
+    flitBuffer *moveQueue{nullptr};
+    flitBuffer *kill_moveQueue{nullptr};
+    flitBuffer *check_probeQueue{nullptr};
+    std::vector<bool> outport_reservations;
 };

 } // namespace garnet
diff --git a/src/mem/ruby/network/garnet/VirtualChannel.cc b/src/mem/ruby/network/garnet/VirtualChannel.cc
index 18e89a09b9..2e55f3466d 100644
--- a/src/mem/ruby/network/garnet/VirtualChannel.cc
+++ b/src/mem/ruby/network/garnet/VirtualChannel.cc
@@ -81,6 +81,12 @@ VirtualChannel::functionalRead(Packet *pkt, WriteMask &mask)
     return inputBuffer.functionalRead(pkt, mask);
 }

+bool
+VirtualChannel::containsHeadAndTail() const
+{
+    return inputBuffer.containsHeadAndTail();
+}
+
 uint32_t
 VirtualChannel::functionalWrite(Packet *pkt)
 {
diff --git a/src/mem/ruby/network/garnet/VirtualChannel.hh b/src/mem/ruby/network/garnet/VirtualChannel.hh
index 04b046b697..428183bb59 100644
--- a/src/mem/ruby/network/garnet/VirtualChannel.hh
+++ b/src/mem/ruby/network/garnet/VirtualChannel.hh
@@ -63,6 +63,7 @@ class VirtualChannel
     inline Tick get_enqueue_time()          { return m_enqueue_time; }
     inline void set_enqueue_time(Tick time) { m_enqueue_time = time; }
     inline VC_state_type get_state()        { return m_vc_state.first; }
+    bool containsHeadAndTail() const;

     inline bool
     isReady(Tick curTime)
diff --git a/src/mem/ruby/network/garnet/flit.cc b/src/mem/ruby/network/garnet/flit.cc
index d31d826c93..0cc578296e 100644
--- a/src/mem/ruby/network/garnet/flit.cc
+++ b/src/mem/ruby/network/garnet/flit.cc
@@ -51,7 +51,7 @@ flit::flit(int packet_id, int id, int  vc, int vnet, RouteInfo route, int size,
     m_enqueue_time = curTime;
     m_dequeue_time = curTime;
     m_time = curTime;
-    m_packet_id = id;
+    m_packet_id = packet_id;
     m_id = id;
     m_vnet = vnet;
     m_vc = vc;
@@ -73,6 +73,66 @@ flit::flit(int packet_id, int id, int  vc, int vnet, RouteInfo route, int size,
         m_type = BODY_;
 }

+// SPIN control flit constructors (optional paths)
+// PROBE/MOVE/CHECK_PROBE carry source info; KILL_MOVE minimal
+flit::flit(int src_id, int src_inp_port, int src_vc, int vnet,
+           flit_type type, Tick curTime, const std::queue<int> &path)
+{
+    m_size = 1;
+    m_msg_ptr = nullptr;
+    m_enqueue_time = curTime;
+    m_dequeue_time = curTime;
+    m_time = curTime;
+    m_packet_id = -1;
+    m_id = 0;
+    m_vnet = vnet;
+    m_vc = src_vc;
+    m_route = RouteInfo();
+    m_stage.first = I_;
+    m_stage.second = curTime;
+    m_width = 0;
+    msgSize = 0;
+    m_type = type;
+    m_source_id = src_id;
+    m_source_inp_port = src_inp_port;
+    m_source_vc = src_vc;
+    m_inport = src_inp_port;
+    m_path = path;
+    // For PROBE, set next outport directly from the path's front
+    if (type == PROBE_) {
+        m_outport = m_path.empty() ? -1 : m_path.front();
+    } else if (type == MOVE_ || type == CHECK_PROBE_) {
+        // Consume first hop from the path as this cycle's outport
+        m_outport = m_path.empty() ? -1 : getPathTop();
+    }
+}
+
+flit::flit(int src_id, const std::queue<int> &path, Tick curTime, int inport)
+{
+    m_size = 1;
+    m_msg_ptr = nullptr;
+    m_enqueue_time = curTime;
+    m_dequeue_time = curTime;
+    m_time = curTime;
+    m_packet_id = -1;
+    m_id = 0;
+    m_vnet = 0;
+    m_vc = -1;
+    m_route = RouteInfo();
+    m_stage.first = I_;
+    m_stage.second = curTime;
+    m_width = 0;
+    msgSize = 0;
+    m_type = KILL_MOVE_;
+    m_source_id = src_id;
+    m_source_inp_port = inport;
+    m_inport = inport;
+    m_source_vc = -1;
+    m_path = path;
+    // For KILL_MOVE_, consume the path head as the outport
+    m_outport = m_path.empty() ? -1 : getPathTop();
+}
+
 flit *
 flit::serialize(int ser_id, int parts, uint32_t bWidth)
 {
@@ -116,6 +176,7 @@ flit::print(std::ostream& out) const
     out << "Size=" << m_size << " ";
     out << "Vnet=" << m_vnet << " ";
     out << "VC=" << m_vc << " ";
+    out << "SrcRouter=" << m_source_id << " ";
     out << "Src NI=" << m_route.src_ni << " ";
     out << "Src Router=" << m_route.src_router << " ";
     out << "Dest NI=" << m_route.dest_ni << " ";
diff --git a/src/mem/ruby/network/garnet/flit.hh b/src/mem/ruby/network/garnet/flit.hh
index a52d7416ae..2076a9751e 100644
--- a/src/mem/ruby/network/garnet/flit.hh
+++ b/src/mem/ruby/network/garnet/flit.hh
@@ -33,6 +33,7 @@

 #include <cassert>
 #include <iostream>
+#include <queue>

 #include "base/types.hh"
 #include "mem/ruby/network/garnet/CommonTypes.hh"
@@ -53,6 +54,10 @@ class flit
     flit() {}
     flit(int packet_id, int id, int vc, int vnet, RouteInfo route, int size,
          MsgPtr msg_ptr, int MsgSize, uint32_t bWidth, Tick curTime);
+    // SPIN control flits
+    flit(int src_id, int src_inp_port, int src_vc, int vnet,
+         flit_type type, Tick curTime, const std::queue<int> &path);
+    flit(int src_id, const std::queue<int> &path, Tick curTime, int inport);

     virtual ~flit(){};

@@ -115,6 +120,32 @@ class flit

     uint32_t m_width;
     int msgSize;
+
+    // --- SPIN (optional) helpers ---
+    // When SPIN is enabled, control flits use these helpers to coordinate
+    // progress along frozen paths. They have no effect otherwise.
+    void setMustSend(bool v=true) { m_must_send = v; }
+    bool getMustSend() const { return m_must_send; }
+    void setPartOfMove(bool v=true) { m_part_of_move = v; }
+    bool isPartOfMove() const { return m_part_of_move; }
+    void setSourceIds(int src_id, int src_inport, int src_vc) {
+        m_source_id = src_id; m_source_inp_port = src_inport; m_source_vc = src_vc;
+    }
+    int getSourceId() const { return m_source_id; }
+    int getSourceInport() const { return m_source_inp_port; }
+    int getSourceVc() const { return m_source_vc; }
+    void setInport(int port) { m_inport = port; }
+    int getInport() const { return m_inport; }
+    // Path stack utilities for control flits
+    void setPath(const std::queue<int> &p) { m_path = p; }
+    std::queue<int> get_path() const { return m_path; }
+    int getPathTop() { int v = m_path.front(); m_path.pop(); return v; }
+    int peekPathTop() const { return m_path.empty() ? -1 : m_path.front(); }
+    unsigned getNumTurns() const { return (unsigned)m_path.size(); }
+    // Delay accounting in ticks
+    void addDelay(Tick t) { m_delay += t; }
+    void subDelay(Tick t) { if (t <= m_delay) m_delay -= t; else m_delay = 0; }
+    Tick getDelay() const { return m_delay; }
   protected:
     int m_packet_id;
     int m_id;
@@ -129,6 +160,16 @@ class flit
     int m_outport;
     Tick src_delay;
     std::pair<flit_stage, Tick> m_stage;
+
+    // SPIN-related (optional) metadata
+    bool m_must_send = false;
+    bool m_part_of_move = false;
+    int m_source_id = -1;
+    int m_source_inp_port = -1;
+    int m_source_vc = -1;
+    int m_inport = -1;
+    std::queue<int> m_path;
+    Tick m_delay = 0;
 };

 inline std::ostream&
diff --git a/src/mem/ruby/network/garnet/flitBuffer.cc b/src/mem/ruby/network/garnet/flitBuffer.cc
index 6b3b56cfe7..52e4471ba3 100644
--- a/src/mem/ruby/network/garnet/flitBuffer.cc
+++ b/src/mem/ruby/network/garnet/flitBuffer.cc
@@ -98,6 +98,21 @@ flitBuffer::functionalRead(Packet *pkt, WriteMask &mask)
     return read;
 }

+bool
+flitBuffer::containsHeadAndTail() const
+{
+    bool has_head = false;
+    bool has_tail = false;
+    for (auto *f : m_buffer) {
+        if (f->get_type() == HEAD_ || f->get_type() == HEAD_TAIL_)
+            has_head = true;
+        if (f->get_type() == TAIL_ || f->get_type() == HEAD_TAIL_)
+            has_tail = true;
+        if (has_head && has_tail) return true;
+    }
+    return has_head && has_tail;
+}
+
 uint32_t
 flitBuffer::functionalWrite(Packet *pkt)
 {
diff --git a/src/mem/ruby/network/garnet/flitBuffer.hh b/src/mem/ruby/network/garnet/flitBuffer.hh
index 089c931951..0088d005c3 100644
--- a/src/mem/ruby/network/garnet/flitBuffer.hh
+++ b/src/mem/ruby/network/garnet/flitBuffer.hh
@@ -59,6 +59,7 @@ class flitBuffer
     bool isFull();
     void setMaxSize(int maximum);
     int getSize() const { return m_buffer.size(); }
+    bool containsHeadAndTail() const;

     flit *
     getTopFlit()
diff --git a/test.py b/test.py
new file mode 100644
index 0000000000..1466ac8756
--- /dev/null
+++ b/test.py
@@ -0,0 +1,628 @@
+#!/usr/bin/env python3
+"""
+Built-in-config plotting for gem5 Garnet topology comparison.
+Input CSV must have (header row): Topology,Traffic,InjectionRate,Throughput,PacketsInjected,PacketsReceived,AvgTotalLatency,AvgHops
+
+Outputs go to OUTDIR:
+- throughput_vs_injection_<TRAFFIC>.png
+- latency_vs_injection_<TRAFFIC>.png
+- latency_vs_throughput_<TRAFFIC>.png
+- facet_throughput_vs_injection.png
+- peak_throughput_heatmap.png
+- knee_injection_rate_heatmap.png
+- results_summary.csv
+- inj_rate_vs_throughput_<TOPOLOGY>.png (NEW)
+- throughput_vs_latency_<TOPOLOGY>.png (NEW)
+"""
+
+import os
+import sys
+import math
+import pandas as pd
+import numpy as np
+import matplotlib.pyplot as plt
+import seaborn as sns
+import warnings
+
+# ============================== CONFIG ======================================
+CSV_FILE = "./lab4/sec2/results.csv"
+OUTDIR = "./lab4/sec2/plots"
+DPI = 300
+
+# Knee = first InjectionRate where latency >= KNEE_FACTOR * low-load latency
+KNEE_FACTOR = 2.0
+
+# Optional filters (set to [] or None to use all)
+FILTER_TRAFFIC = None  # e.g., ["uniform_random", "transpose"]
+FILTER_TOPOLOGY = None  # e.g., ["Mesh_XY", "Torus_XY"]
+
+# Show interactive windows? (usually False for batch)
+SHOW = False
+
+# ============================================================================
+
+def ensure_columns(df: pd.DataFrame) -> pd.DataFrame:
+    df.columns = [c.strip() for c in df.columns]
+
+    # Backward-compat column aliases
+    rename_map = {}
+    if "SentPackets" in df.columns and "PacketsInjected" not in df.columns:
+        rename_map["SentPackets"] = "PacketsInjected"
+    if "ReceivedPackets" in df.columns and "PacketsReceived" not in df.columns:
+        rename_map["ReceivedPackets"] = "PacketsReceived"
+    if (
+        "AvgPacketLatency" in df.columns
+        and "AvgTotalLatency" not in df.columns
+    ):
+        rename_map["AvgPacketLatency"] = "AvgTotalLatency"
+
+    if rename_map:
+        df = df.rename(columns=rename_map)
+
+    if "Topology" not in df.columns:
+        # If older CSVs didn't include topology, assume Mesh_XY to keep plotting usable
+        df["Topology"] = "Mesh_XY"
+
+    required = [
+        "Topology",
+        "Traffic",
+        "InjectionRate",
+        "Throughput",
+        "PacketsInjected",
+        "PacketsReceived",
+        "AvgTotalLatency",
+        "AvgHops",
+    ]
+    missing = [c for c in required if c not in df.columns]
+    if missing:
+        raise ValueError(
+            f"CSV missing columns: {missing}\nFound: {list(df.columns)}"
+        )
+
+    return df
+
+
+def to_numeric(df: pd.DataFrame) -> pd.DataFrame:
+    for col in [
+        "InjectionRate",
+        "Throughput",
+        "PacketsInjected",
+        "PacketsReceived",
+        "AvgTotalLatency",
+        "AvgHops",
+    ]:
+        df[col] = pd.to_numeric(df[col], errors="coerce")
+
+    df = df.dropna(subset=["InjectionRate", "Throughput", "AvgTotalLatency"])
+    return df
+
+
+def maybe_filter(df: pd.DataFrame) -> pd.DataFrame:
+    if FILTER_TRAFFIC:
+        keep = set([t.strip() for t in FILTER_TRAFFIC if str(t).strip()])
+        df = df[df["Traffic"].isin(keep)]
+    if FILTER_TOPOLOGY:
+        keep = set([t.strip() for t in FILTER_TOPOLOGY if str(t).strip()])
+        df = df[df["Topology"].isin(keep)]
+    return df
+
+
+def safe_name(s: str) -> str:
+    return str(s).replace(" ", "_").replace("/", "_")
+
+
+def summarize(df: pd.DataFrame, knee_factor: float) -> pd.DataFrame:
+    rows = []
+    for (traffic, topo), g in df.groupby(["Traffic", "Topology"], sort=True):
+        g = g.sort_values("InjectionRate")
+
+        # Peak throughput
+        idx_peak = g["Throughput"].idxmax()
+        peak_tp = g.loc[idx_peak, "Throughput"]
+        inj_at_peak = g.loc[idx_peak, "InjectionRate"]
+
+        # Low-load latency at min inj
+        min_inj = g["InjectionRate"].min()
+        low_latency = g.loc[g["InjectionRate"].idxmin(), "AvgTotalLatency"]
+
+        # Knee
+        knee_thresh = low_latency * knee_factor
+        knee_rows = g[g["AvgTotalLatency"] >= knee_thresh]
+        knee_inj = (
+            knee_rows["InjectionRate"].min()
+            if not knee_rows.empty
+            else np.nan
+        )
+
+        rows.append(
+            {
+                "Traffic": traffic,
+                "Topology": topo,
+                "PeakThroughput": peak_tp,
+                "InjectionAtPeakTP": inj_at_peak,
+                "LowLoadInjection": float(min_inj),
+                "LowLoadLatency": float(low_latency),
+                "KneeFactor": knee_factor,
+                "KneeInjectionRate": (
+                    float(knee_inj) if not pd.isna(knee_inj) else np.nan
+                ),
+            }
+        )
+
+    return pd.DataFrame(rows).sort_values(["Traffic", "Topology"])
+
+
+# NEW FUNCTION: Injection Rate vs Throughput (by Topology)
+def plot_inj_rate_vs_throughput_by_topology(df, topology, outdir, dpi):
+    """
+    Plot Injection Rate vs Throughput for a specific topology.
+    Different traffic patterns (flow patterns) are shown in the same plot.
+    """
+    plt.figure(figsize=(8, 6))
+
+    sns.lineplot(
+        data=df,
+        x="InjectionRate",
+        y="Throughput",
+        hue="Traffic",
+        style="Traffic",
+        markers=True,
+        dashes=False,
+    )
+
+    plt.title(
+        f"Injection Rate vs Throughput — {topology}",
+        fontsize=16,
+        fontweight="bold",
+    )
+    plt.xlabel("Injection Rate (pkts/node/cycle)")
+    plt.ylabel("Throughput (accepted pkts/node/cycle)")
+    plt.grid(True, linestyle="--", alpha=0.4)
+    plt.legend(title="Traffic Pattern")
+
+    fn = os.path.join(
+        outdir, f"inj_rate_vs_throughput_{safe_name(topology)}.png"
+    )
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+# NEW FUNCTION: Throughput vs Latency (by Topology)
+def plot_throughput_vs_latency_by_topology(df, topology, outdir, dpi):
+    """
+    Plot Throughput vs Latency for a specific topology.
+    Different traffic patterns (flow patterns) are shown in the same plot.
+    """
+    plt.figure(figsize=(8, 6))
+
+    sns.lineplot(
+        data=df,
+        x="Throughput",
+        y="AvgTotalLatency",
+        hue="Traffic",
+        style="Traffic",
+        markers=True,
+        dashes=False,
+    )
+
+    plt.title(
+        f"Throughput vs Latency — {topology}",
+        fontsize=16,
+        fontweight="bold"
+    )
+    plt.xlabel("Throughput (accepted pkts/node/cycle)")
+    plt.ylabel("Average Packet Latency (cycles)")
+    plt.ylim(bottom=0)
+    plt.grid(True, linestyle="--", alpha=0.4)
+    plt.legend(title="Traffic Pattern")
+
+    fn = os.path.join(
+        outdir, f"throughput_vs_latency_{safe_name(topology)}.png"
+    )
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+# EXISTING FUNCTIONS (keeping all the original functionality)
+def plot_throughput_vs_injection(df, traffic, outdir, dpi):
+    plt.figure(figsize=(12, 7))
+    sns.lineplot(
+        data=df,
+        x="InjectionRate",
+        y="Throughput",
+        hue="Topology",
+        style="Topology",
+        markers=True,
+        dashes=False,
+    )
+    plt.title(
+        f"Throughput vs Injection Rate — {traffic}",
+        fontsize=16,
+        fontweight="bold",
+    )
+    plt.xlabel("Injection Rate (pkts/node/cycle)")
+    plt.ylabel("Throughput (accepted pkts/node/cycle)")
+    plt.grid(True, linestyle="--", alpha=0.4)
+    plt.legend(title="Topology")
+
+    fn = os.path.join(
+        outdir, f"throughput_vs_injection_{safe_name(traffic)}.png"
+    )
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def plot_latency_vs_injection(df, traffic, outdir, dpi):
+    plt.figure(figsize=(12, 7))
+    sns.lineplot(
+        data=df,
+        x="InjectionRate",
+        y="AvgTotalLatency",
+        hue="Topology",
+        style="Topology",
+        markers=True,
+        dashes=False,
+    )
+    plt.title(
+        f"Latency vs Injection Rate — {traffic}",
+        fontsize=16,
+        fontweight="bold",
+    )
+    plt.xlabel("Injection Rate (pkts/node/cycle)")
+    plt.ylabel("Average Packet Latency (cycles)")
+    plt.ylim(bottom=0)
+    plt.grid(True, linestyle="--", alpha=0.4)
+    plt.legend(title="Topology")
+
+    # Annotate knee (first inj where latency >= 2x low-load)
+    try:
+        for topo, g in df.groupby("Topology"):
+            g = g.sort_values("InjectionRate")
+            low = g.loc[g["InjectionRate"].idxmin(), "AvgTotalLatency"]
+            thresh = low * KNEE_FACTOR
+            knees = g[g["AvgTotalLatency"] >= thresh]
+            if not knees.empty:
+                knee_inj = float(knees["InjectionRate"].min())
+                plt.axvline(
+                    knee_inj,
+                    color="black",
+                    linestyle="--",
+                    alpha=0.3,
+                )
+                plt.text(
+                    knee_inj,
+                    plt.gca().get_ylim()[1] * 0.85,
+                    f"knee {topo}\n@ {knee_inj:.3f}",
+                    rotation=90,
+                    va="top",
+                    ha="right",
+                    fontsize=8,
+                    alpha=0.7,
+                )
+    except Exception as e:
+        warnings.warn(f"Knee annotation skipped: {e}")
+
+    fn = os.path.join(outdir, f"latency_vs_injection_{safe_name(traffic)}.png")
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def plot_latency_vs_throughput(df, traffic, outdir, dpi):
+    plt.figure(figsize=(12, 7))
+    sns.lineplot(
+        data=df,
+        x="Throughput",
+        y="AvgTotalLatency",
+        hue="Topology",
+        style="Topology",
+        markers=True,
+        dashes=False,
+    )
+    plt.title(
+        f"Latency vs Throughput — {traffic}",
+        fontsize=16,
+        fontweight="bold"
+    )
+    plt.xlabel("Throughput (accepted pkts/node/cycle)")
+    plt.ylabel("Average Packet Latency (cycles)")
+    plt.ylim(bottom=0)
+    plt.grid(True, linestyle="--", alpha=0.4)
+    plt.legend(title="Topology")
+
+    fn = os.path.join(
+        outdir, f"latency_vs_throughput_{safe_name(traffic)}.png"
+    )
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def plot_throughput_vs_injection_logy(df, traffic, outdir, dpi):
+    plt.figure(figsize=(12, 7))
+    sns.lineplot(
+        data=df,
+        x="InjectionRate",
+        y="Throughput",
+        hue="Topology",
+        style="Topology",
+        markers=True,
+        dashes=False,
+    )
+    plt.title(
+        f"Throughput vs Injection Rate (log-y) — {traffic}",
+        fontsize=16,
+        fontweight="bold",
+    )
+    plt.xlabel("Injection Rate (pkts/node/cycle)")
+    plt.ylabel("Throughput (accepted pkts/node/cycle)")
+    ymin = max(1e-6, float(np.nanmin(df["Throughput"].replace(0, np.nan))))
+    plt.yscale("log")
+    plt.ylim(bottom=ymin)
+    plt.grid(True, which="both", linestyle="--", alpha=0.4)
+    plt.legend(title="Topology")
+
+    fn = os.path.join(
+        outdir, f"throughput_vs_injection_{safe_name(traffic)}_logy.png"
+    )
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def plot_latency_vs_injection_logy(df, traffic, outdir, dpi):
+    plt.figure(figsize=(12, 7))
+    sns.lineplot(
+        data=df,
+        x="InjectionRate",
+        y="AvgTotalLatency",
+        hue="Topology",
+        style="Topology",
+        markers=True,
+        dashes=False,
+    )
+    plt.title(
+        f"Latency vs Injection Rate (log-y) — {traffic}",
+        fontsize=16,
+        fontweight="bold",
+    )
+    plt.xlabel("Injection Rate (pkts/node/cycle)")
+    plt.ylabel("Average Packet Latency (cycles)")
+    ymin = max(
+        1e-3, float(np.nanmin(df["AvgTotalLatency"].replace(0, np.nan)))
+    )
+    plt.yscale("log")
+    plt.ylim(bottom=ymin)
+    plt.grid(True, which="both", linestyle="--", alpha=0.4)
+    plt.legend(title="Topology")
+
+    fn = os.path.join(
+        outdir, f"latency_vs_injection_{safe_name(traffic)}_logy.png"
+    )
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def plot_latency_vs_throughput_logy(df, traffic, outdir, dpi):
+    plt.figure(figsize=(12, 7))
+    sns.lineplot(
+        data=df,
+        x="Throughput",
+        y="AvgTotalLatency",
+        hue="Topology",
+        style="Topology",
+        markers=True,
+        dashes=False,
+    )
+    plt.title(
+        f"Latency vs Throughput (log-y) — {traffic}",
+        fontsize=16,
+        fontweight="bold",
+    )
+    plt.xlabel("Throughput (accepted pkts/node/cycle)")
+    plt.ylabel("Average Packet Latency (cycles)")
+    ymin = max(
+        1e-3, float(np.nanmin(df["AvgTotalLatency"].replace(0, np.nan)))
+    )
+    plt.yscale("log")
+    plt.ylim(bottom=ymin)
+    plt.grid(True, which="both", linestyle="--", alpha=0.4)
+    plt.legend(title="Topology")
+
+    fn = os.path.join(
+        outdir, f"latency_vs_throughput_{safe_name(traffic)}_logy.png"
+    )
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def facet_throughput_vs_injection(df, outdir, dpi):
+    g = sns.FacetGrid(
+        df,
+        col="Traffic",
+        hue="Topology",
+        sharex=True,
+        sharey=True,
+        height=4,
+        aspect=1.2,
+    )
+    g.map_dataframe(
+        sns.lineplot, x="InjectionRate", y="Throughput", marker="o"
+    )
+    g.add_legend(title="Topology")
+    g.set_axis_labels("Injection Rate", "Throughput")
+    g.set_titles(col_template="{col_name}")
+
+    for ax in g.axes.flat:
+        ax.grid(True, linestyle="--", alpha=0.4)
+
+    fn = os.path.join(outdir, "facet_throughput_vs_injection.png")
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def plot_peak_tp_heatmap(summary_df, outdir, dpi):
+    pivot = summary_df.pivot(
+        index="Topology", columns="Traffic", values="PeakThroughput"
+    )
+    plt.figure(
+        figsize=(
+            1.2 * max(6, len(pivot.columns)),
+            0.9 * max(5, len(pivot.index)),
+        )
+    )
+    sns.heatmap(
+        pivot,
+        annot=True,
+        fmt=".3f",
+        linewidths=0.5,
+        cbar_kws={"label": "Peak Throughput"},
+    )
+    plt.title(
+        "Peak Throughput Heatmap (Topology × Traffic)",
+        fontsize=16,
+        fontweight="bold",
+    )
+    plt.ylabel("Topology")
+    plt.xlabel("Traffic")
+
+    fn = os.path.join(outdir, "peak_throughput_heatmap.png")
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def plot_knee_heatmap(summary_df, outdir, dpi):
+    pivot = summary_df.pivot(
+        index="Topology", columns="Traffic", values="KneeInjectionRate"
+    )
+    plt.figure(
+        figsize=(
+            1.2 * max(6, len(pivot.columns)),
+            0.9 * max(5, len(pivot.index)),
+        )
+    )
+    sns.heatmap(
+        pivot,
+        annot=True,
+        fmt=".3f",
+        linewidths=0.5,
+        cbar_kws={"label": "Knee Injection Rate"},
+    )
+    plt.title(
+        "Knee (Latency Blow-up) Injection Rate Heatmap",
+        fontsize=16,
+        fontweight="bold",
+    )
+    plt.ylabel("Topology")
+    plt.xlabel("Traffic")
+
+    fn = os.path.join(outdir, "knee_injection_rate_heatmap.png")
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def main():
+    os.makedirs(OUTDIR, exist_ok=True)
+
+    # Style
+    sns.set_theme(style="whitegrid", palette="deep")
+
+    # Load CSV (assumes header row exists)
+    try:
+        df = pd.read_csv(CSV_FILE)
+    except FileNotFoundError:
+        print(f"Error: File not found: {CSV_FILE}")
+        sys.exit(1)
+
+    df = ensure_columns(df)
+    df = to_numeric(df)
+    df = maybe_filter(df)
+
+    if df.empty:
+        print("No data after filtering. Check CSV/filters.")
+        sys.exit(0)
+
+    # Sort for nice lines
+    df = df.sort_values(["Traffic", "Topology", "InjectionRate"]).reset_index(
+        drop=True
+    )
+
+    # Summary metrics & save
+    summary_df = summarize(df, knee_factor=KNEE_FACTOR)
+    summary_path = os.path.join(OUTDIR, "results_summary.csv")
+    summary_df.to_csv(summary_path, index=False)
+
+    saved = []
+
+    # Per-traffic comparison (topologies as hue) - EXISTING PLOTS
+    for traffic, g in df.groupby("Traffic", sort=True):
+        saved.append(plot_throughput_vs_injection(g, traffic, OUTDIR, DPI))
+        saved.append(
+            plot_throughput_vs_injection_logy(g, traffic, OUTDIR, DPI)
+        )
+        saved.append(plot_latency_vs_injection(g, traffic, OUTDIR, DPI))
+        saved.append(plot_latency_vs_injection_logy(g, traffic, OUTDIR, DPI))
+        saved.append(plot_latency_vs_throughput(g, traffic, OUTDIR, DPI))
+        saved.append(plot_latency_vs_throughput_logy(g, traffic, OUTDIR, DPI))
+
+    # NEW: Per-topology comparison (traffic patterns as hue)
+    for topology, g in df.groupby("Topology", sort=True):
+        saved.append(plot_inj_rate_vs_throughput_by_topology(g, topology, OUTDIR, DPI))
+        saved.append(plot_throughput_vs_latency_by_topology(g, topology, OUTDIR, DPI))
+
+    # Aggregated visuals
+    saved.append(facet_throughput_vs_injection(df, OUTDIR, DPI))
+    saved.append(plot_peak_tp_heatmap(summary_df, OUTDIR, DPI))
+    saved.append(plot_knee_heatmap(summary_df, OUTDIR, DPI))
+
+    print("\n=== Saved Figures ===")
+    for s in saved:
+        print(s)
+    print(f"\nSummary CSV: {summary_path}")
+
+    # Quick highlights: best topology per traffic
+    print("\n=== Peak Throughput by Traffic/Topology ===")
+    for traffic, g in summary_df.groupby("Traffic"):
+        best = g.sort_values("PeakThroughput", ascending=False).iloc[0]
+        knee = (
+            f"{best.KneeInjectionRate:.3f}"
+            if not math.isnan(best.KneeInjectionRate)
+            else "N/A"
+        )
+        print(
+            f"{traffic:>16}: best {best.Topology} @ {best.PeakThroughput:.4f} (inj={best.InjectionAtPeakTP:.3f}) | knee @ {knee}"
+        )
+
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
diff --git a/topo_plot.py b/topo_plot.py
new file mode 100644
index 0000000000..cf8ad253ff
--- /dev/null
+++ b/topo_plot.py
@@ -0,0 +1,521 @@
+#!/usr/bin/env python3
+"""
+Built-in-config plotting for gem5 Garnet topology comparison.
+
+Input CSV must have (header row):
+Topology,Traffic,InjectionRate,Throughput,PacketsInjected,PacketsReceived,AvgTotalLatency,AvgHops
+
+Outputs go to OUTDIR:
+- throughput_vs_injection_<TRAFFIC>.png
+- latency_vs_injection_<TRAFFIC>.png
+- latency_vs_throughput_<TRAFFIC>.png
+- facet_throughput_vs_injection.png
+- peak_throughput_heatmap.png
+- knee_injection_rate_heatmap.png
+- results_summary.csv
+"""
+
+import os
+import sys
+import math
+import pandas as pd
+import numpy as np
+import matplotlib.pyplot as plt
+import seaborn as sns
+import warnings
+
+# ============================== CONFIG ======================================
+CSV_FILE = "./lab4/sec2/results.csv"
+OUTDIR = "./lab4/sec2/plots"
+DPI = 300
+
+# Knee = first InjectionRate where latency >= KNEE_FACTOR * low-load latency
+KNEE_FACTOR = 2.0
+
+# Optional filters (set to [] or None to use all)
+FILTER_TRAFFIC = None  # e.g., ["uniform_random", "transpose"]
+FILTER_TOPOLOGY = None  # e.g., ["Mesh_XY", "Torus_XY"]
+
+# Show interactive windows? (usually False for batch)
+SHOW = False
+# ============================================================================
+
+
+def ensure_columns(df: pd.DataFrame) -> pd.DataFrame:
+    df.columns = [c.strip() for c in df.columns]
+    # Backward-compat column aliases
+    rename_map = {}
+    if "SentPackets" in df.columns and "PacketsInjected" not in df.columns:
+        rename_map["SentPackets"] = "PacketsInjected"
+    if "ReceivedPackets" in df.columns and "PacketsReceived" not in df.columns:
+        rename_map["ReceivedPackets"] = "PacketsReceived"
+    if (
+        "AvgPacketLatency" in df.columns
+        and "AvgTotalLatency" not in df.columns
+    ):
+        rename_map["AvgPacketLatency"] = "AvgTotalLatency"
+    if rename_map:
+        df = df.rename(columns=rename_map)
+
+    if "Topology" not in df.columns:
+        # If older CSVs didn’t include topology, assume Mesh_XY to keep plotting usable
+        df["Topology"] = "Mesh_XY"
+
+    required = [
+        "Topology",
+        "Traffic",
+        "InjectionRate",
+        "Throughput",
+        "PacketsInjected",
+        "PacketsReceived",
+        "AvgTotalLatency",
+        "AvgHops",
+    ]
+    missing = [c for c in required if c not in df.columns]
+    if missing:
+        raise ValueError(
+            f"CSV missing columns: {missing}\nFound: {list(df.columns)}"
+        )
+    return df
+
+
+def to_numeric(df: pd.DataFrame) -> pd.DataFrame:
+    for col in [
+        "InjectionRate",
+        "Throughput",
+        "PacketsInjected",
+        "PacketsReceived",
+        "AvgTotalLatency",
+        "AvgHops",
+    ]:
+        df[col] = pd.to_numeric(df[col], errors="coerce")
+    df = df.dropna(subset=["InjectionRate", "Throughput", "AvgTotalLatency"])
+    return df
+
+
+def maybe_filter(df: pd.DataFrame) -> pd.DataFrame:
+    if FILTER_TRAFFIC:
+        keep = set([t.strip() for t in FILTER_TRAFFIC if str(t).strip()])
+        df = df[df["Traffic"].isin(keep)]
+    if FILTER_TOPOLOGY:
+        keep = set([t.strip() for t in FILTER_TOPOLOGY if str(t).strip()])
+        df = df[df["Topology"].isin(keep)]
+    return df
+
+
+def safe_name(s: str) -> str:
+    return str(s).replace(" ", "_").replace("/", "_")
+
+
+def summarize(df: pd.DataFrame, knee_factor: float) -> pd.DataFrame:
+    rows = []
+    for (traffic, topo), g in df.groupby(["Traffic", "Topology"], sort=True):
+        g = g.sort_values("InjectionRate")
+        # Peak throughput
+        idx_peak = g["Throughput"].idxmax()
+        peak_tp = g.loc[idx_peak, "Throughput"]
+        inj_at_peak = g.loc[idx_peak, "InjectionRate"]
+        # Low-load latency at min inj
+        min_inj = g["InjectionRate"].min()
+        low_latency = g.loc[g["InjectionRate"].idxmin(), "AvgTotalLatency"]
+        # Knee
+        knee_thresh = low_latency * knee_factor
+        knee_rows = g[g["AvgTotalLatency"] >= knee_thresh]
+        knee_inj = (
+            knee_rows["InjectionRate"].min() if not knee_rows.empty else np.nan
+        )
+        rows.append(
+            {
+                "Traffic": traffic,
+                "Topology": topo,
+                "PeakThroughput": peak_tp,
+                "InjectionAtPeakTP": inj_at_peak,
+                "LowLoadInjection": float(min_inj),
+                "LowLoadLatency": float(low_latency),
+                "KneeFactor": knee_factor,
+                "KneeInjectionRate": (
+                    float(knee_inj) if not pd.isna(knee_inj) else np.nan
+                ),
+            }
+        )
+    return pd.DataFrame(rows).sort_values(["Traffic", "Topology"])
+
+
+def plot_throughput_vs_injection(df, traffic, outdir, dpi):
+    plt.figure(figsize=(8, 6))
+    sns.lineplot(
+        data=df,
+        x="InjectionRate",
+        y="Throughput",
+        hue="Topology",
+        style="Topology",
+        markers=True,
+        dashes=False,
+    )
+    plt.title(
+        f"Throughput vs Injection Rate — {traffic}",
+        fontsize=16,
+        fontweight="bold",
+    )
+    plt.xlabel("Injection Rate (pkts/node/cycle)")
+    plt.ylabel("Throughput (accepted pkts/node/cycle)")
+    plt.grid(True, linestyle="--", alpha=0.4)
+    plt.legend(title="Topology")
+    fn = os.path.join(
+        outdir, f"throughput_vs_injection_{safe_name(traffic)}.png"
+    )
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def plot_latency_vs_injection(df, traffic, outdir, dpi):
+    plt.figure(figsize=(8, 6))
+    sns.lineplot(
+        data=df,
+        x="InjectionRate",
+        y="AvgTotalLatency",
+        hue="Topology",
+        style="Topology",
+        markers=True,
+        dashes=False,
+    )
+    plt.title(
+        f"Latency vs Injection Rate — {traffic}",
+        fontsize=16,
+        fontweight="bold",
+    )
+    plt.xlabel("Injection Rate (pkts/node/cycle)")
+    plt.ylabel("Average Packet Latency (cycles)")
+    plt.ylim(bottom=0)
+    plt.grid(True, linestyle="--", alpha=0.4)
+    plt.legend(title="Topology")
+    # Annotate knee (first inj where latency >= 2x low-load)
+    try:
+        for topo, g in df.groupby("Topology"):
+            g = g.sort_values("InjectionRate")
+            low = g.loc[g["InjectionRate"].idxmin(), "AvgTotalLatency"]
+            thresh = low * KNEE_FACTOR
+            knees = g[g["AvgTotalLatency"] >= thresh]
+            if not knees.empty:
+                knee_inj = float(knees["InjectionRate"].min())
+                plt.axvline(
+                    knee_inj,
+                    color="black",
+                    linestyle="--",
+                    alpha=0.3,
+                )
+                plt.text(
+                    knee_inj,
+                    plt.gca().get_ylim()[1] * 0.85,
+                    f"knee {topo}\n@ {knee_inj:.3f}",
+                    rotation=90,
+                    va="top",
+                    ha="right",
+                    fontsize=8,
+                    alpha=0.7,
+                )
+    except Exception as e:
+        warnings.warn(f"Knee annotation skipped: {e}")
+    fn = os.path.join(outdir, f"latency_vs_injection_{safe_name(traffic)}.png")
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def plot_latency_vs_throughput(df, traffic, outdir, dpi):
+    plt.figure(figsize=(8, 6))
+    sns.lineplot(
+        data=df,
+        x="Throughput",
+        y="AvgTotalLatency",
+        hue="Topology",
+        style="Topology",
+        markers=True,
+        dashes=False,
+    )
+    plt.title(
+        f"Latency vs Throughput — {traffic}", fontsize=16, fontweight="bold"
+    )
+    plt.xlabel("Throughput (accepted pkts/node/cycle)")
+    plt.ylabel("Average Packet Latency (cycles)")
+    plt.ylim(bottom=0)
+    plt.grid(True, linestyle="--", alpha=0.4)
+    plt.legend(title="Topology")
+    fn = os.path.join(
+        outdir, f"latency_vs_throughput_{safe_name(traffic)}.png"
+    )
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def plot_throughput_vs_injection_logy(df, traffic, outdir, dpi):
+    plt.figure(figsize=(8, 6))
+    sns.lineplot(
+        data=df,
+        x="InjectionRate",
+        y="Throughput",
+        hue="Topology",
+        style="Topology",
+        markers=True,
+        dashes=False,
+    )
+    plt.title(
+        f"Throughput vs Injection Rate (log-y) — {traffic}",
+        fontsize=16,
+        fontweight="bold",
+    )
+    plt.xlabel("Injection Rate (pkts/node/cycle)")
+    plt.ylabel("Throughput (accepted pkts/node/cycle)")
+    ymin = max(1e-6, float(np.nanmin(df["Throughput"].replace(0, np.nan))))
+    plt.yscale("log")
+    plt.ylim(bottom=ymin)
+    plt.grid(True, which="both", linestyle="--", alpha=0.4)
+    plt.legend(title="Topology")
+    fn = os.path.join(
+        outdir, f"throughput_vs_injection_{safe_name(traffic)}_logy.png"
+    )
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def plot_latency_vs_injection_logy(df, traffic, outdir, dpi):
+    plt.figure(figsize=(8, 6))
+    sns.lineplot(
+        data=df,
+        x="InjectionRate",
+        y="AvgTotalLatency",
+        hue="Topology",
+        style="Topology",
+        markers=True,
+        dashes=False,
+    )
+    plt.title(
+        f"Latency vs Injection Rate (log-y) — {traffic}",
+        fontsize=16,
+        fontweight="bold",
+    )
+    plt.xlabel("Injection Rate (pkts/node/cycle)")
+    plt.ylabel("Average Packet Latency (cycles)")
+    ymin = max(
+        1e-3, float(np.nanmin(df["AvgTotalLatency"].replace(0, np.nan)))
+    )
+    plt.yscale("log")
+    plt.ylim(bottom=ymin)
+    plt.grid(True, which="both", linestyle="--", alpha=0.4)
+    plt.legend(title="Topology")
+    fn = os.path.join(
+        outdir, f"latency_vs_injection_{safe_name(traffic)}_logy.png"
+    )
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def plot_latency_vs_throughput_logy(df, traffic, outdir, dpi):
+    plt.figure(figsize=(8, 6))
+    sns.lineplot(
+        data=df,
+        x="Throughput",
+        y="AvgTotalLatency",
+        hue="Topology",
+        style="Topology",
+        markers=True,
+        dashes=False,
+    )
+    plt.title(
+        f"Latency vs Throughput (log-y) — {traffic}",
+        fontsize=16,
+        fontweight="bold",
+    )
+    plt.xlabel("Throughput (accepted pkts/node/cycle)")
+    plt.ylabel("Average Packet Latency (cycles)")
+    ymin = max(
+        1e-3, float(np.nanmin(df["AvgTotalLatency"].replace(0, np.nan)))
+    )
+    plt.yscale("log")
+    plt.ylim(bottom=ymin)
+    plt.grid(True, which="both", linestyle="--", alpha=0.4)
+    plt.legend(title="Topology")
+    fn = os.path.join(
+        outdir, f"latency_vs_throughput_{safe_name(traffic)}_logy.png"
+    )
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def facet_throughput_vs_injection(df, outdir, dpi):
+    g = sns.FacetGrid(
+        df,
+        col="Traffic",
+        hue="Topology",
+        sharex=True,
+        sharey=True,
+        height=4,
+        aspect=1.2,
+    )
+    g.map_dataframe(
+        sns.lineplot, x="InjectionRate", y="Throughput", marker="o"
+    )
+    g.add_legend(title="Topology")
+    g.set_axis_labels("Injection Rate", "Throughput")
+    g.set_titles(col_template="{col_name}")
+    for ax in g.axes.flat:
+        ax.grid(True, linestyle="--", alpha=0.4)
+    fn = os.path.join(outdir, "facet_throughput_vs_injection.png")
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def plot_peak_tp_heatmap(summary_df, outdir, dpi):
+    pivot = summary_df.pivot(
+        index="Topology", columns="Traffic", values="PeakThroughput"
+    )
+    plt.figure(
+        figsize=(
+            1.2 * max(6, len(pivot.columns)),
+            0.9 * max(5, len(pivot.index)),
+        )
+    )
+    sns.heatmap(
+        pivot,
+        annot=True,
+        fmt=".3f",
+        linewidths=0.5,
+        cbar_kws={"label": "Peak Throughput"},
+    )
+    plt.title(
+        "Peak Throughput Heatmap (Topology × Traffic)",
+        fontsize=16,
+        fontweight="bold",
+    )
+    plt.ylabel("Topology")
+    plt.xlabel("Traffic")
+    fn = os.path.join(outdir, "peak_throughput_heatmap.png")
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def plot_knee_heatmap(summary_df, outdir, dpi):
+    pivot = summary_df.pivot(
+        index="Topology", columns="Traffic", values="KneeInjectionRate"
+    )
+    plt.figure(
+        figsize=(
+            1.2 * max(6, len(pivot.columns)),
+            0.9 * max(5, len(pivot.index)),
+        )
+    )
+    sns.heatmap(
+        pivot,
+        annot=True,
+        fmt=".3f",
+        linewidths=0.5,
+        cbar_kws={"label": "Knee Injection Rate"},
+    )
+    plt.title(
+        "Knee (Latency Blow-up) Injection Rate Heatmap",
+        fontsize=16,
+        fontweight="bold",
+    )
+    plt.ylabel("Topology")
+    plt.xlabel("Traffic")
+    fn = os.path.join(outdir, "knee_injection_rate_heatmap.png")
+    plt.savefig(fn, dpi=dpi, bbox_inches="tight")
+    if SHOW:
+        plt.show()
+    plt.close()
+    return fn
+
+
+def main():
+    os.makedirs(OUTDIR, exist_ok=True)
+
+    # Style
+    sns.set_theme(style="whitegrid", palette="deep")
+
+    # Load CSV (assumes header row exists)
+    try:
+        df = pd.read_csv(CSV_FILE)
+    except FileNotFoundError:
+        print(f"Error: File not found: {CSV_FILE}")
+        sys.exit(1)
+
+    df = ensure_columns(df)
+    df = to_numeric(df)
+    df = maybe_filter(df)
+
+    if df.empty:
+        print("No data after filtering. Check CSV/filters.")
+        sys.exit(0)
+
+    # Sort for nice lines
+    df = df.sort_values(["Traffic", "Topology", "InjectionRate"]).reset_index(
+        drop=True
+    )
+
+    # Summary metrics & save
+    summary_df = summarize(df, knee_factor=KNEE_FACTOR)
+    summary_path = os.path.join(OUTDIR, "results_summary.csv")
+    summary_df.to_csv(summary_path, index=False)
+
+    saved = []
+
+    # Per-traffic comparison (topologies as hue)
+    for traffic, g in df.groupby("Traffic", sort=True):
+        saved.append(plot_throughput_vs_injection(g, traffic, OUTDIR, DPI))
+        saved.append(
+            plot_throughput_vs_injection_logy(g, traffic, OUTDIR, DPI)
+        )
+        saved.append(plot_latency_vs_injection(g, traffic, OUTDIR, DPI))
+        saved.append(plot_latency_vs_injection_logy(g, traffic, OUTDIR, DPI))
+        saved.append(plot_latency_vs_throughput(g, traffic, OUTDIR, DPI))
+        saved.append(plot_latency_vs_throughput_logy(g, traffic, OUTDIR, DPI))
+
+    # Aggregated visuals
+    saved.append(facet_throughput_vs_injection(df, OUTDIR, DPI))
+    saved.append(plot_peak_tp_heatmap(summary_df, OUTDIR, DPI))
+    saved.append(plot_knee_heatmap(summary_df, OUTDIR, DPI))
+
+    print("\n=== Saved Figures ===")
+    for s in saved:
+        print(s)
+    print(f"\nSummary CSV: {summary_path}")
+
+    # Quick highlights: best topology per traffic
+    print("\n=== Peak Throughput by Traffic/Topology ===")
+    for traffic, g in summary_df.groupby("Traffic"):
+        best = g.sort_values("PeakThroughput", ascending=False).iloc[0]
+        knee = (
+            f"{best.KneeInjectionRate:.3f}"
+            if not math.isnan(best.KneeInjectionRate)
+            else "N/A"
+        )
+        print(
+            f"{traffic:>16}: best {best.Topology} @ {best.PeakThroughput:.4f} (inj={best.InjectionAtPeakTP:.3f}) | knee @ {knee}"
+        )
+
+
+if __name__ == "__main__":
+    main()
diff --git a/zlink.sh b/zlink.sh
new file mode 100644
index 0000000000..c4e29461ca
--- /dev/null
+++ b/zlink.sh
@@ -0,0 +1,175 @@
+#!/usr/bin/env bash
+# TSV latency sweep for Sparse 3D topologies
+# - Focuses on two topologies: Sparse3D_Pillars and Sparse3D_Pillars_torus
+# - Keeps XY link latency = 1
+# - Sweeps Z-link (TSV) effective latency in {1,2,4}
+# - Reuses base settings from prior experiments (run_topo.sh)
+
+###############################################################################
+# Basic config
+###############################################################################
+GEM5_EXECUTABLE="./build/NULL/gem5.opt"
+GEM5_CONFIG="configs/example/garnet_synth_traffic.py"
+
+RESULTS_DIR="lab4/sparse3d_tsv"
+TEMP_DIR="${RESULTS_DIR}/tmp"
+OUTPUT_CSV="${RESULTS_DIR}/results.csv"
+PLOT_DIR="${RESULTS_DIR}/plots"
+SIM_CYCLES=10000
+
+# Node counts (match earlier sweeps)
+NUM_CPUS=64
+NUM_DIRS=64
+
+# Concurrency: cap parallel background runs to 8
+JOBS=32
+
+# Synthetic patterns to sweep (same as earlier quick runs)
+SYNTHETIC_PATTERNS=(uniform_random)
+
+# Injection rates to sweep (0.02 -> 0.70 step 0.02)
+INJECTION_RATES=$(seq 0.02 0.02 0.50)
+
+# Keep XY link latency fixed at 1
+XY_LINK_LATENCY=1
+
+# TSV/Z-link effective latency values to sweep
+Z_LATENCIES=(1 2 4)
+
+# Two target topologies (name|extra_args)
+TOPOLOGY_BASES=(
+  #"Mesh3D_XYZ|--mesh-rows=4"
+  "Sparse3D_Pillars|--mesh-rows=4"
+  "Cluster3D_Hub|--mesh-rows=4"
+  "Hier3D_Chiplet|--mesh-rows=4"
+)
+
+###############################################################################
+# Safety checks
+###############################################################################
+set -u  # no undefined variables
+rm -rf "${RESULTS_DIR}" "${TEMP_DIR}"
+mkdir -p "${RESULTS_DIR}" "${TEMP_DIR}" "${PLOT_DIR}"
+
+if [[ ! -x "${GEM5_EXECUTABLE}" ]]; then
+  echo "ERROR: gem5 executable not found/executable at: ${GEM5_EXECUTABLE}"
+  exit 1
+fi
+if [[ ! -f "${GEM5_CONFIG}" ]]; then
+  echo "ERROR: gem5 config not found at: ${GEM5_CONFIG}"
+  exit 1
+fi
+
+###############################################################################
+# CSV header
+###############################################################################
+if [[ ! -f "${OUTPUT_CSV}" ]]; then
+  echo "Topology,Traffic,InjectionRate,Throughput,PacketsInjected,PacketsReceived,AvgTotalLatency,AvgHops" > "${OUTPUT_CSV}"
+fi
+
+LOCKFILE="${OUTPUT_CSV}.lock"
+touch "${LOCKFILE}"
+
+###############################################################################
+# Helper: throttle to $JOBS background tasks
+###############################################################################
+wait_for_slot() {
+  while [[ "$(jobs -rp | wc -l | tr -d ' ')" -ge "${JOBS}" ]]; do
+    sleep 0.2
+  done
+}
+
+###############################################################################
+# One simulation run
+# Args: <topology> <topo_args> <traffic> <rate> <z_latency>
+###############################################################################
+run_one() {
+  local topo="$1"
+  local topo_args="$2"
+  local traffic="$3"
+  local rate="$4"
+  local zlat="$5"   # desired effective Z-link latency
+
+  # Folder-friendly rate tag: e.g., 0.010 -> 0p010
+  local rate_tag
+  rate_tag="$(printf "%.3f" "${rate}" | sed 's/\\.//g')"
+
+  # Label topology with Z latency for plotting (six curves total)
+  local topo_label="${topo}_Z${zlat}"
+
+  # Output directory per run
+  local OUTDIR="${TEMP_DIR}/m5out_${topo_label}_${traffic}_${rate_tag}"
+  mkdir -p "${OUTDIR}"
+
+  # Map requested Z latency to TSV controls with XY link-latency=1
+  # Effective Z = link_latency * slowdown / speedup; with link_latency=1 -> Z = slowdown/speedup
+  local tsv_slowdown=${zlat}
+  local tsv_speedup=1
+
+  "${GEM5_EXECUTABLE}" -d "${OUTDIR}" "${GEM5_CONFIG}" \
+    --network=garnet --num-cpus="${NUM_CPUS}" --num-dirs="${NUM_DIRS}" \
+    --topology="${topo}" \
+    --inj-vnet=0 --synthetic="${traffic}" \
+    --sim-cycles="${SIM_CYCLES}" --injectionrate="${rate}" --escape-vc --routing-algorithm=5 \
+    --link-latency="${XY_LINK_LATENCY}" --tsv-slowdown="${tsv_slowdown}" --tsv-speedup="${tsv_speedup}" \
+    ${topo_args} \
+    > "${OUTDIR}/gem5.log" 2>&1
+
+  # Parse stats and append to CSV (using the labeled topology)
+  local STATS="${OUTDIR}/stats.txt"
+  if [[ -f "${STATS}" ]]; then
+    local line
+    line="$(
+      awk -v topology="${topo_label}" -v traffic="${traffic}" -v rate="${rate}" \
+          -v cycles="${SIM_CYCLES}" -v nodes="${NUM_CPUS}" \
+          '\
+        BEGIN{ inj=0; rec=0; t_lat=0; hops=0; }\
+        /system\.ruby\.network\.packets_injected::total/ { inj=$2 }\
+        /system\.ruby\.network\.packets_received::total/ { rec=$2 }\
+        /system\.ruby\.network\.average_packet_latency/  { t_lat=$2 }\
+        /system\.ruby\.network\.average_hops/            { hops=$2 }\
+        END {\
+          throughput = (nodes>0 && cycles>0) ? rec / cycles / nodes : 0;\
+          printf "%s,%s,%.3f,%.6f,%.0f,%.0f,%.4f,%.4f\n",\
+                 topology, traffic, rate, throughput, inj, rec, t_lat, hops\
+        }' "${STATS}"
+    )"
+
+    if command -v flock >/dev/null 2>&1; then
+      (
+        flock -x 200
+        echo "${line}" >> "${OUTPUT_CSV}"
+      ) 200>"${LOCKFILE}"
+    else
+      echo "${line}" >> "${OUTPUT_CSV}"
+    fi
+  else
+    echo "WARN: No stats.txt for ${topo_label}/${traffic} at rate ${rate} (OUTDIR=${OUTDIR})"
+  fi
+}
+
+###############################################################################
+# Sweep loops (parallelized)
+###############################################################################
+echo "Starting TSV latency sweeps for Sparse 3D topologies..."
+echo "Topologies: ${#TOPOLOGY_BASES[@]} | Z-lats: ${#Z_LATENCIES[@]} | Patterns: ${#SYNTHETIC_PATTERNS[@]} | Rates: $(echo "${INJECTION_RATES}" | wc -w) | Jobs: ${JOBS}"
+
+for entry in "${TOPOLOGY_BASES[@]}"; do
+  IFS='|' read -r TOPO TOPO_ARGS <<< "${entry}"
+  for zlat in "${Z_LATENCIES[@]}"; do
+    for traffic in "${SYNTHETIC_PATTERNS[@]}"; do
+      for rate in ${INJECTION_RATES}; do
+        printf "Queue: topo=%s, Z=%s, traffic=%s, rate=%.3f\n" "${TOPO}" "${zlat}" "${traffic}" "${rate}"
+        wait_for_slot
+        run_one "${TOPO}" "${TOPO_ARGS}" "${traffic}" "${rate}" "${zlat}" &
+      done
+    done
+  done
+done
+
+wait
+
+echo "------------------------------------------------------------------------"
+echo "All simulations complete. Results CSV: ${OUTPUT_CSV}"
+echo "Per-run logs under: ${TEMP_DIR}/m5out_*/* (see gem5.log for details)"
+echo "------------------------------------------------------------------------"
diff --git a/zlink_plot.py b/zlink_plot.py
new file mode 100644
index 0000000000..f31e3118b8
--- /dev/null
+++ b/zlink_plot.py
@@ -0,0 +1,485 @@
+#!/usr/bin/env python3
+"""
+Plot curves from Z-link TSV sweeps and support different topologies.
+
+Usage:
+  python3 zlink_plot.py [csv_path] [out_dir] [--match REGEX] [--traffic NAME]
+                        [--per-topo]
+
+Examples:
+  # Use defaults that match zlink.sh
+  python3 zlink_plot.py
+
+  # Explicit CSV/output dir, include any topologies with Z tags
+  python3 zlink_plot.py results.csv plots
+
+  # Only plot Mesh and Torus variants (with Z-latency suffix)
+  python3 zlink_plot.py results.csv plots --match "(Mesh|Torus).*_Z\\d+$"
+
+  # Plot per base-topology figures for a given traffic
+  python3 zlink_plot.py results.csv plots --per-topo --traffic uniform_random
+
+Input CSV schema (header row required):
+  Topology,Traffic,InjectionRate,Throughput,PacketsInjected,PacketsReceived,AvgTotalLatency,AvgHops
+
+Notes:
+- This script assumes the sweep driver is `zlink.sh` located next to this file.
+- With no arguments, it looks for CSV at: ./lab4/sparse3d_tsv/results.csv
+  and writes plots to: ./lab4/sparse3d_tsv/plots
+
+By convention, the 'Topology' field can include a Z-latency tag, e.g.:
+  Sparse3D_Pillars_Z1, Sparse3D_Pillars_Z2, Sparse3D_Pillars_Z4,
+  Sparse3D_Pillars_torus_Z1, Sparse3D_Pillars_torus_Z2, Sparse3D_Pillars_torus_Z4
+This script derives a base-topology name by removing the trailing `_Z<d+>` when present.
+"""
+
+import os
+import sys
+import re
+import pandas as pd
+import matplotlib.pyplot as plt
+import seaborn as sns
+import numpy as np
+from typing import Tuple, Optional
+
+
+# Built-in paths relative to this script
+HERE = os.path.dirname(os.path.abspath(__file__))
+ZLINK_SH = os.path.join(HERE, "zlink.sh")
+DEFAULT_RESULTS_DIR = os.path.join(HERE, "lab4", "sparse3d_tsv")
+DEFAULT_CSV = os.path.join(DEFAULT_RESULTS_DIR, "results.csv")
+DEFAULT_PLOT_DIR = os.path.join(DEFAULT_RESULTS_DIR, "plots")
+
+
+def resolve_paths_and_args(
+    argv: list,
+) -> Tuple[str, str, Optional[str], Optional[str], bool]:
+    """Parse arguments and return (csv_path, out_dir, match_regex, traffic, per_topo)."""
+    # Very small argparse replacement to keep the script lightweight and
+    # backward-compatible with previous positional-only usage.
+    csv_path = DEFAULT_CSV
+    out_dir = DEFAULT_PLOT_DIR
+    match_regex: Optional[str] = None
+    traffic: Optional[str] = None
+    per_topo = False
+
+    # Collect flags first
+    flags = []
+    pos = []
+    for a in argv[1:]:
+        if a.startswith("--"):
+            flags.append(a)
+        else:
+            pos.append(a)
+
+    # Positional handling: 0 or 2 (csv, out_dir)
+    if len(pos) == 0:
+        pass  # keep defaults
+    elif len(pos) == 2:
+        csv_path, out_dir = pos
+    else:
+        print(
+            "Usage: python3 zlink_plot.py [csv_path] [out_dir] [--match REGEX] [--traffic NAME] [--per-topo]",
+            file=sys.stderr,
+        )
+        sys.exit(1)
+
+    # Flag parsing (simple, order-independent)
+    i = 0
+    while i < len(flags):
+        f = flags[i]
+        if f == "--per-topo":
+            per_topo = True
+            i += 1
+            continue
+        if f == "--match":
+            if i + 1 >= len(flags):
+                print(
+                    "ERROR: --match requires a REGEX argument", file=sys.stderr
+                )
+                sys.exit(1)
+            match_regex = flags[i + 1]
+            i += 2
+            continue
+        if f == "--traffic":
+            if i + 1 >= len(flags):
+                print(
+                    "ERROR: --traffic requires a NAME argument",
+                    file=sys.stderr,
+                )
+                sys.exit(1)
+            traffic = flags[i + 1]
+            i += 2
+            continue
+        print(f"ERROR: Unknown flag {f}", file=sys.stderr)
+        sys.exit(1)
+
+    return csv_path, out_dir, match_regex, traffic, per_topo
+
+
+def main():
+    (
+        csv_path,
+        out_dir,
+        match_regex,
+        opt_traffic,
+        per_topo,
+    ) = resolve_paths_and_args(sys.argv)
+
+    if not os.path.exists(csv_path):
+        print(f"ERROR: CSV not found at: {csv_path}", file=sys.stderr)
+        if os.path.isfile(ZLINK_SH):
+            print(
+                f"Hint: generate it by running the sweep: {ZLINK_SH}",
+                file=sys.stderr,
+            )
+        else:
+            print(
+                "Hint: expected sweep driver 'zlink.sh' next to this script.",
+                file=sys.stderr,
+            )
+        sys.exit(1)
+
+    os.makedirs(out_dir, exist_ok=True)
+
+    df = pd.read_csv(csv_path)
+    # Basic cleaning
+    df.columns = [c.strip() for c in df.columns]
+    for col in ["InjectionRate", "Throughput", "AvgTotalLatency"]:
+        if col in df.columns:
+            df[col] = pd.to_numeric(df[col], errors="coerce")
+    df = df.dropna(subset=["InjectionRate", "Throughput", "AvgTotalLatency", "Topology"])  # type: ignore
+
+    # Derive base topology (strip trailing _Z<d+>) and Z tag if present
+    df["base_topo"] = df["Topology"].str.replace(r"_Z\d+$", "", regex=True)
+    z_series = df["Topology"].str.extract(r"_Z(\d+)$")[0]
+    df["z_tag"] = z_series.where(~z_series.isna(), other="NA")
+
+    # Filter by regex if provided, else default to any topology with a Z tag
+    if match_regex:
+        try:
+            df = df[df["Topology"].str.contains(match_regex, regex=True)]
+        except re.error as e:
+            print(f"ERROR: invalid --match regex: {e}", file=sys.stderr)
+            sys.exit(1)
+    else:
+        df = df[df["Topology"].str.contains(r"_Z\d+$", regex=True)]
+
+    if df.empty:
+        print(
+            "No matching TSV data found in CSV after filtering.",
+            file=sys.stderr,
+        )
+        sys.exit(0)
+
+    # Traffic selection
+    traffic: str
+    if opt_traffic is not None:
+        if opt_traffic not in set(df["Traffic"].unique()):
+            print(
+                f"ERROR: --traffic {opt_traffic} not found. Available: {sorted(df['Traffic'].unique())}",
+                file=sys.stderr,
+            )
+            sys.exit(1)
+        traffic = opt_traffic
+    else:
+        uniq = list(sorted(set(df["Traffic"].unique())))
+        if len(uniq) == 1:
+            traffic = uniq[0]
+        elif "uniform_random" in uniq:
+            traffic = "uniform_random"
+        else:
+            traffic = uniq[0]
+            print(
+                f"Info: multiple Traffic values found {uniq}. Defaulting to '{traffic}'.",
+                file=sys.stderr,
+            )
+
+    df_t = df[df["Traffic"] == traffic].copy()
+
+    # Sort lines for nicer plotting
+    df_t = df_t.sort_values(["Topology", "InjectionRate"]).reset_index(
+        drop=True
+    )
+
+    # Match topo_plot.py style
+    sns.set_theme(style="whitegrid", palette="deep")
+
+    # Helpers for labeling, titles, and filename tagging
+    def _sanitize(s: str) -> str:
+        return re.sub(r"[^A-Za-z0-9_.-]+", "_", s)
+
+    def _label_for_combined(topo: str) -> str:
+        return topo
+
+    def _label_for_per_topo(z: str) -> str:
+        return f"Z{z}"
+
+    # 1) Throughput vs InjectionRate (linear)
+    def _plot_throughput(ax, groups, xcol="InjectionRate", ycol="Throughput"):
+        for label, g in groups:
+            g = g.sort_values([xcol])
+            sns.lineplot(
+                data=g,
+                x=xcol,
+                y=ycol,
+                ax=ax,
+                label=label,
+                marker="o",
+                dashes=False,
+            )
+        ax.set_xlabel("Injection Rate (pkts/node/cycle)")
+        ax.set_ylabel("Throughput (accepted pkts/node/cycle)")
+        ax.grid(True, linestyle="--", alpha=0.4)
+        ax.legend(title="Topology")
+
+    # 2) Latency vs InjectionRate (linear)
+    def _plot_latency(
+        ax, groups, xcol="InjectionRate", ycol="AvgTotalLatency"
+    ):
+        for label, g in groups:
+            g = g.sort_values([xcol])
+            sns.lineplot(
+                data=g,
+                x=xcol,
+                y=ycol,
+                ax=ax,
+                label=label,
+                marker="s",
+                dashes=False,
+            )
+        ax.set_xlabel("Injection Rate (pkts/node/cycle)")
+        ax.set_ylabel("Average Packet Latency (cycles)")
+        ax.set_ylim(bottom=0)
+        ax.grid(True, linestyle="--", alpha=0.4)
+        ax.legend(title="Topology")
+
+    # 3) Latency vs Throughput (useful for saturation view)
+    def _plot_latency_vs_tp(
+        ax, groups, xcol="Throughput", ycol="AvgTotalLatency"
+    ):
+        for label, g in groups:
+            g = g.sort_values([xcol])
+            sns.lineplot(
+                data=g,
+                x=xcol,
+                y=ycol,
+                ax=ax,
+                label=label,
+                marker="d",
+                dashes=False,
+            )
+        ax.set_xlabel("Throughput (accepted pkts/node/cycle)")
+        ax.set_ylabel("Average Packet Latency (cycles)")
+        ax.set_ylim(bottom=0)
+        ax.grid(True, linestyle="--", alpha=0.4)
+        ax.legend(title="Topology")
+
+    saved_paths = []
+
+    if per_topo:
+        # Generate separate figures per base topology; legend shows Z tags
+        for base in sorted(df_t["base_topo"].unique()):
+            df_b = df_t[df_t["base_topo"] == base]
+            if df_b.empty:
+                continue
+
+            groups_tp = [
+                (_label_for_per_topo(z), g) for z, g in df_b.groupby("z_tag")
+            ]
+
+            # Throughput vs Injection (linear)
+            fig, ax = plt.subplots(figsize=(8, 6))
+            _plot_throughput(ax, groups_tp)
+            ax.set_title(
+                f"Throughput vs Injection Rate — {traffic}\n{base} (Z-latency sweep)",
+                fontsize=16,
+                fontweight="bold",
+            )
+            out_tp = os.path.join(
+                out_dir,
+                f"{_sanitize(base)}_{_sanitize(traffic)}_throughput_vs_injection.png",
+            )
+            fig.savefig(out_tp, dpi=300, bbox_inches="tight")
+            plt.close(fig)
+            saved_paths.append(out_tp)
+
+            # Throughput vs Injection (log-y)
+            fig, ax = plt.subplots(figsize=(8, 6))
+            _plot_throughput(ax, groups_tp)
+            ymin = max(
+                1e-6, float(np.nanmin(df_b["Throughput"].replace(0, np.nan)))
+            )
+            ax.set_yscale("log")
+            ax.set_ylim(bottom=ymin)
+            ax.grid(True, which="both", linestyle="--", alpha=0.4)
+            ax.set_title(
+                f"Throughput vs Injection Rate (log-y) — {traffic}\n{base} (Z-latency sweep)",
+                fontsize=16,
+                fontweight="bold",
+            )
+            out_tp_logy = os.path.join(
+                out_dir,
+                f"{_sanitize(base)}_{_sanitize(traffic)}_throughput_vs_injection_logy.png",
+            )
+            fig.savefig(out_tp_logy, dpi=300, bbox_inches="tight")
+            plt.close(fig)
+            saved_paths.append(out_tp_logy)
+
+            # Latency vs Injection (linear)
+            fig, ax = plt.subplots(figsize=(8, 6))
+            _plot_latency(ax, groups_tp)
+            ax.set_title(
+                f"Latency vs Injection Rate — {traffic}\n{base} (Z-latency sweep)",
+                fontsize=16,
+                fontweight="bold",
+            )
+            out_lat = os.path.join(
+                out_dir,
+                f"{_sanitize(base)}_{_sanitize(traffic)}_latency_vs_injection.png",
+            )
+            fig.savefig(out_lat, dpi=300, bbox_inches="tight")
+            plt.close(fig)
+            saved_paths.append(out_lat)
+
+            # Latency vs Injection (log-y)
+            fig, ax = plt.subplots(figsize=(8, 6))
+            _plot_latency(ax, groups_tp)
+            ymin_lat = max(
+                1e-3,
+                float(np.nanmin(df_b["AvgTotalLatency"].replace(0, np.nan))),
+            )
+            ax.set_yscale("log")
+            ax.set_ylim(bottom=ymin_lat)
+            ax.grid(True, which="both", linestyle="--", alpha=0.4)
+            ax.set_title(
+                f"Latency vs Injection Rate (log-y) — {traffic}\n{base} (Z-latency sweep)",
+                fontsize=16,
+                fontweight="bold",
+            )
+            out_lat_logy = os.path.join(
+                out_dir,
+                f"{_sanitize(base)}_{_sanitize(traffic)}_latency_vs_injection_logy.png",
+            )
+            fig.savefig(out_lat_logy, dpi=300, bbox_inches="tight")
+            plt.close(fig)
+            saved_paths.append(out_lat_logy)
+
+            # Latency vs Throughput
+            fig, ax = plt.subplots(figsize=(8, 6))
+            _plot_latency_vs_tp(ax, groups_tp)
+            ax.set_title(
+                f"Latency vs Throughput — {traffic}\n{base} (Z-latency sweep)",
+                fontsize=16,
+                fontweight="bold",
+            )
+            out_lvt = os.path.join(
+                out_dir,
+                f"{_sanitize(base)}_{_sanitize(traffic)}_latency_vs_throughput.png",
+            )
+            fig.savefig(out_lvt, dpi=300, bbox_inches="tight")
+            plt.close(fig)
+            saved_paths.append(out_lvt)
+    else:
+        # Combined figures across all matching topologies; legend shows full topology
+        groups_all = [
+            (_label_for_combined(topo), g)
+            for topo, g in df_t.groupby("Topology")
+        ]
+
+        # Throughput vs Injection (linear)
+        fig, ax = plt.subplots(figsize=(8, 6))
+        _plot_throughput(ax, groups_all)
+        ax.set_title(
+            f"Throughput vs Injection Rate — {traffic}\nTopologies: {', '.join(sorted(df_t['base_topo'].unique()))}",
+            fontsize=16,
+            fontweight="bold",
+        )
+        out_tp = os.path.join(
+            out_dir, "tsv_latency_sweep_throughput_vs_injection.png"
+        )
+        fig.savefig(out_tp, dpi=300, bbox_inches="tight")
+        plt.close(fig)
+        saved_paths.append(out_tp)
+
+        # Throughput vs Injection (log-y)
+        fig, ax = plt.subplots(figsize=(8, 6))
+        _plot_throughput(ax, groups_all)
+        ymin = max(
+            1e-6, float(np.nanmin(df_t["Throughput"].replace(0, np.nan)))
+        )
+        ax.set_yscale("log")
+        ax.set_ylim(bottom=ymin)
+        ax.grid(True, which="both", linestyle="--", alpha=0.4)
+        ax.set_title(
+            f"Throughput vs Injection Rate (log-y) — {traffic}\nTopologies: {', '.join(sorted(df_t['base_topo'].unique()))}",
+            fontsize=16,
+            fontweight="bold",
+        )
+        out_tp_logy = os.path.join(
+            out_dir, "tsv_latency_sweep_throughput_vs_injection_logy.png"
+        )
+        fig.savefig(out_tp_logy, dpi=300, bbox_inches="tight")
+        plt.close(fig)
+        saved_paths.append(out_tp_logy)
+
+        # Latency vs Injection (linear)
+        fig, ax = plt.subplots(figsize=(8, 6))
+        _plot_latency(ax, groups_all)
+        ax.set_title(
+            f"Latency vs Injection Rate — {traffic}\nTopologies: {', '.join(sorted(df_t['base_topo'].unique()))}",
+            fontsize=16,
+            fontweight="bold",
+        )
+        out_lat = os.path.join(
+            out_dir, "tsv_latency_sweep_latency_vs_injection.png"
+        )
+        fig.savefig(out_lat, dpi=300, bbox_inches="tight")
+        plt.close(fig)
+        saved_paths.append(out_lat)
+
+        # Latency vs Injection (log-y)
+        fig, ax = plt.subplots(figsize=(8, 6))
+        _plot_latency(ax, groups_all)
+        ymin_lat = max(
+            1e-3, float(np.nanmin(df_t["AvgTotalLatency"].replace(0, np.nan)))
+        )
+        ax.set_yscale("log")
+        ax.set_ylim(bottom=ymin_lat)
+        ax.grid(True, which="both", linestyle="--", alpha=0.4)
+        ax.set_title(
+            f"Latency vs Injection Rate (log-y) — {traffic}\nTopologies: {', '.join(sorted(df_t['base_topo'].unique()))}",
+            fontsize=16,
+            fontweight="bold",
+        )
+        out_lat_logy = os.path.join(
+            out_dir, "tsv_latency_sweep_latency_vs_injection_logy.png"
+        )
+        fig.savefig(out_lat_logy, dpi=300, bbox_inches="tight")
+        plt.close(fig)
+        saved_paths.append(out_lat_logy)
+
+        # Latency vs Throughput
+        fig, ax = plt.subplots(figsize=(8, 6))
+        _plot_latency_vs_tp(ax, groups_all)
+        ax.set_title(
+            f"Latency vs Throughput — {traffic}",
+            fontsize=16,
+            fontweight="bold",
+        )
+        out_lvt = os.path.join(
+            out_dir, "tsv_latency_sweep_latency_vs_throughput.png"
+        )
+        fig.savefig(out_lvt, dpi=300, bbox_inches="tight")
+        plt.close(fig)
+        saved_paths.append(out_lvt)
+
+    print("Saved:")
+    for p in saved_paths:
+        print(p)
+    if os.path.isfile(ZLINK_SH):
+        print(f"Sweep script: {ZLINK_SH}")
+
+
+if __name__ == "__main__":
+    main()
